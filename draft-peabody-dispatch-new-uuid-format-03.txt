



dispatch                                                    BGP. Peabody
Internet-Draft                                                          
Updates: 4122 (if approved)                                     K. Davis
Intended status: Standards Track                        16 February 2022
Expires: 20 August 2022


                            New UUID Formats
               draft-peabody-dispatch-new-uuid-format-02

Abstract

   This document presents new UUID formats which address the concerns of
   time-ordered sequencing, reduction of complexity by separating
   minimum requirements from implementation suggestions, a more compact
   text format, support for variable lengths, and general suitability
   for use as a database key.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 20 August 2022.

Copyright Notice

   Copyright (c) 2022 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Revised BSD License text as
   described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Revised BSD License.



Peabody & Davis          Expires 20 August 2022                 [Page 1]

Internet-Draft               new-uuid-format               February 2022


Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   2
   2.  Background  . . . . . . . . . . . . . . . . . . . . . . . . .   3
   3.  Summary of Changes  . . . . . . . . . . . . . . . . . . . . .   5
     3.1.  changelog . . . . . . . . . . . . . . . . . . . . . . . .   5
   4.  UUID Version 6  . . . . . . . . . . . . . . . . . . . . . . .   6
     4.1.  Format  . . . . . . . . . . . . . . . . . . . . . . . . .   6
     4.2.  Creating a UUIDv6 Value . . . . . . . . . . . . . . . . .   8
     4.3.  Example of a UUIDv6 Value . . . . . . . . . . . . . . . .   9
   5.  UUID Version 7  . . . . . . . . . . . . . . . . . . . . . . .   9
     5.1.  Format  . . . . . . . . . . . . . . . . . . . . . . . . .   9
     5.2.  Creating a UUIDv7 Value . . . . . . . . . . . . . . . . .  10
     5.3.  Example of a UUIDv7 Value . . . . . . . . . . . . . . . .  10
   6.  UUID Version 8  . . . . . . . . . . . . . . . . . . . . . . .  10
     6.1.  Format  . . . . . . . . . . . . . . . . . . . . . . . . .  10
   7.  UUID Concerns . . . . . . . . . . . . . . . . . . . . . . . .  11
     7.1.  Storing UUIDs, Opacity  . . . . . . . . . . . . . . . . .  11
     7.2.  Variant and Version Fields  . . . . . . . . . . . . . . .  12
     7.3.  Length (Variable, 128-bit Default)  . . . . . . . . . . .  13
     7.4.  Text Format . . . . . . . . . . . . . . . . . . . . . . .  14
     7.5.  Sorting . . . . . . . . . . . . . . . . . . . . . . . . .  14
     7.6.  Timestamp Granularity . . . . . . . . . . . . . . . . . .  15
     7.7.  Monotonicity and Counters . . . . . . . . . . . . . . . .  15
     7.8.  Global and Local Uniqueness . . . . . . . . . . . . . . .  15
     7.9.  Collision Resistance  . . . . . . . . . . . . . . . . . .  16
     7.10. Unguessability  . . . . . . . . . . . . . . . . . . . . .  16
     7.11. Shared Knowledge  . . . . . . . . . . . . . . . . . . . .  17
     7.12. Documentation . . . . . . . . . . . . . . . . . . . . . .  18
   8.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  18
   9.  Security Considerations . . . . . . . . . . . . . . . . . . .  18
   10. Acknowledgements  . . . . . . . . . . . . . . . . . . . . . .  18
   11. Normative References  . . . . . . . . . . . . . . . . . . . .  18
   12. Informative References  . . . . . . . . . . . . . . . . . . .  19
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  20

1.  Introduction

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [RFC2119].










Peabody & Davis          Expires 20 August 2022                 [Page 2]

Internet-Draft               new-uuid-format               February 2022


2.  Background

   A lot of things have changed in the time since UUIDs were originally
   created.  Modern applications have a need to create and utilize UUIDs
   as the primary identifier for a variety of different items in complex
   computational systems, including but not limited to database primary
   keys, file names, machine or system names, identifiers for
   transactions or other objects or processes.

   A specific use case for UUIDs which has gained popularity is as
   database primary keys.  The motivation for this stems primarily from
   the fact that applications are increasingly distributed in nature.
   Simplistic "auto increment" schemes with integers in sequence do not
   work well in a distributed system since the effort required to
   synchronize such numbers across a network can easily become a burden.
   The fact that UUIDs can be used to create unique and reasonably short
   values in distributed systems without requiring synchronization makes
   them a good candidate for use as a database key in such environments.

   Previous UUID versions 1 through 5 suffer from at least the following
   shortcomings:

   1.  Non-time-ordered UUID versions such as UUIDv4 have poor database
       index locality.  Meaning new values created in succession are not
       close to each other in the index and thus require inserts to be
       performed at random locations.  The negative performance effects
       of which on common structures used for this (B-tree and its
       variants) can be dramatic.

   2.  Introspection/parsing is required to order by time sequence (as
       opposed to being able to peform a simple byte-by-byte
       comparision.

   3.  UUIDv1 utilizes a non-standard timestamp epoch derived from the
       Gregorian Calendar.  More specifically, the Coordinated Universal
       Time (UTC) as a count of 100-nanosecond intervals since
       00:00:00.00, 15 October 1582.

   4.  Privacy and network security issues arise from using a MAC
       address in the node field of Version 1 UUIDs.  Exposed MAC
       addresses can be used as an attack surface to locate machines and
       reveal various other information about such machines (minimally
       manufacturer, potentially other details).

   5.  Many implementation details are specified in [RFC4122] but some
       of the decisions made involve tradeoffs that are neither possible
       to specify for all applications nor necessary to produce
       interoperable implementations.



Peabody & Davis          Expires 20 August 2022                 [Page 3]

Internet-Draft               new-uuid-format               February 2022


   6.  The previous specification also does not distinguish between the
       requirements for generation of a UUID versus an application which
       simply stores one, which are different.

   7.  The only specified text format is unnecessarily verbose at 225%
       the length of the raw bytes.

   8.  A fixed length restricts the options of implementations to choose
       between having shorter (and e.g. values easier for humans to read
       and use) and less unique values, or having longer yet more unique
       values.

   Due to the shortcomings of UUIDv1 and UUIDv4, many widely distributed
   database applications and large application vendors have sought to
   solve the problem of creating a better time-based, sortable unique
   identifier for use as a database key.  This has lead to numerous
   implementations over the past 10+ years solving the same problem in
   slightly different ways.

   While preparing this specification the following 16 different
   implementations were analyzed for trends in total ID length, bit
   Layout, lexical formatting/encoding, timestamp type, timestamp
   format, timestamp accuracy, node format/components, collision
   handling and multi-timestamp tick generation sequencing.

   1.   [ULID] by A.  Feerasta
   2.   [LexicalUUID] by Twitter
   3.   [Snowflake] by Twitter
   4.   [Flake] by Boundary
   5.   [ShardingID] by Instagram
   6.   [KSUID] by Segment
   7.   [Elasticflake] by P.  Pearcy
   8.   [FlakeID] by T.  Pawlak
   9.   [Sonyflake] by Sony
   10.  [orderedUuid] by IT.  Cabrera
   11.  [COMBGUID] by R.  Tallent
   12.  [SID] by A.  Chilton
   13.  [pushID] by Google
   14.  [XID] by O.  Poitrey
   15.  [ObjectID] by MongoDB
   16.  [CUID] by E.  Elliott

   An inspection of these implementations and the issues described above
   has led to this document which attempts to adapt UUIDs to address
   these issues.






Peabody & Davis          Expires 20 August 2022                 [Page 4]

Internet-Draft               new-uuid-format               February 2022


   Note that there are similarities between [ULID] and UUID version 7 as
   described in this document.  In any case, the point here is to
   formalize new UUID formats in a way that is backward compatible with
   UUID and takes into account all of the concerns mentioned herein.

3.  Summary of Changes

   The following UUIDs are hereby introduced:

   1.  UUID version 6: A re-ordering of UUID version 1 so it is sortable
       as an opaque sequence of bytes.  Easy to implement given an
       existing UUIDv1 implementation.
   2.  UUID version 7: A new format which is simpler, time-ordered and
       specified in a way that separates UUID generation requirements
       from generation recommendations from storage requirements.
   3.  UUID version 8: A free-form UUID format which has no explicit
       requirements except maintaining backward compatibility.

3.1.  changelog

   RFC EDITOR PLEASE DELETE THIS SECTION.

   draft-03

      - Reworked the draft body to make the content more concise
      - UUIDv6 section reworked to just the reorder of the timestamp
      - UUIDv7 changed to simplify timestsamp mechanism to just
      millisecond unix timestamp
      - UUIDv8 relaxed to be custom in all elements except version and
      variant
      - Changed UUIDv7 and UUIDv8 to use Variant 111.
      - Added C code samples for UUIDv6 and UUIDv7
      - Added test vectors for UUIDv6 and UUIDv7
      - Version and Variant section combined into Variant and Version
      Fields section.
      - Introduced variable length UUIDs.
      - Introduced alternate encoding techniques via Crockford base32.
      - Changed from pseudo-random number generators to
      cryptographically secure pseudo-random number generator (CSPRNG).
      - Split Encoding and Storage section into more sections: Text
      Format and Storing UUIDs, Opacity
      - Reworked Global Uniqueness under new section Global and Local
      Uniqueness
      - Distributed UUID Generation section replaced with Shared
      Knowledge section
      - Combined redundant topics from all UUIDs into sections such as
      Sorting, Monotonicity and Counters, Collision Resistance, and
      Unguessability



Peabody & Davis          Expires 20 August 2022                 [Page 5]

Internet-Draft               new-uuid-format               February 2022


      - Node verbiage only used in UUIDv6 and v7 and v8 reference random
      instead
      - Clock sequence verbiage changed simply to counter in any section
      other than UUIDv6

   draft-02

      - Added Changelog
      - Fixed misc. grammatical errors
      - Fixed section numbering issue
      - Fixed some UUIDvX reference issues
      - Changed all instances of "motonic" to "monotonic"
      - Changed all instances of "#-bit" to "# bit"
      - Changed "proceeding" veriage to "after" in section 7
      - Added details on how to pad 32 bit unix timestamp to 36 bits in
      UUIDv7
      - Added details on how to truncate 64 bit unix timestamp to 36
      bits in UUIDv7
      - Added forward reference and bullet to UUIDv8 if truncating 64
      bit Unix Epoch is not an option.
      - Fixed bad reference to non-existent "time_or_node" in section
      4.5.4

   draft-01

      - Complete rewrite of entire document.
      - The format, flow and verbiage used in the specification has been
      reworked to mirror the original RFC 4122 and current IETF
      standards.
      - Removed the topics of UUID length modification, alternate UUID
      text formats, and alternate UUID encoding techniques.
      - Research into 16 different historical and current
      implementations of time-based universal identifiers was completed
      at the end of 2020 in attempt to identify trends which have
      directly influenced design decisions in this draft document
      (https://github.com/uuid6/uuid6-ietf-draft/tree/master/research)
      - Prototype implementation have been completed for UUIDv6, UUIDv7,
      and UUIDv8 in various languages by many GitHub community members.
      (https://github.com/uuid6/prototypes)

4.  UUID Version 6

4.1.  Format

   UUID version 6 aims to be the easiest new version to implement by
   using the same information from a UUID version 1 and changing the
   order of the timestamp value.




Peabody & Davis          Expires 20 August 2022                 [Page 6]

Internet-Draft               new-uuid-format               February 2022


   Instead of splitting the timestamp into the low, mid and high
   sections from UUIDv1, UUIDv6 changes this sequence so the timestamp
   is stored from most to least significant.  I.e.  Given a 60-bit
   timestamp value as specified for UUIDv1 in [RFC4122], Section 4.1.4,
   for UUIDv6, the first 48 most significant bits are stored first,
   followed by the 4-bit version (same position), followed by the
   remaining 12 bits of the original 60-bit timestamp.

   The format for the 16-byte, 128 bit UUIDv6 is shown in Figure 1

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                            time_top                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |            time_top           |  ver  |     time_bottom       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |var|                    remaining_bytes                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        remaining_bytes                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                   Figure 1: UUIDv6 Field and Bit Layout

   time_top:
      The most significant 48 bits of the 60-bit timestamp.  Occupies
      bits 0 through 47 (octets 0-5).

   ver:
      The version value, set to 6 (0110b).  Occupies bits 48 through 51
      (top 4 bits of octet 6).

   time_bottom:
      The remaining 12 bits of the 60-bit timestamp.  Occupies bits 52
      through 63 (bottom 4 bits of octet 6 and octets 7-8)

   var:
      The 2 bit UUID variant (10)

   remaining_bytes bytes:
      The remaining 62 Bits of the UUID as defined by [RFC4122],
      Section 4.1.6 or [RFC4122], Section 4.5









Peabody & Davis          Expires 20 August 2022                 [Page 7]

Internet-Draft               new-uuid-format               February 2022


   In the specification for UUIDv1, the clock sequence [RFC4122],
   Section 4.1.5 and node value [RFC4122], Section 4.1.6 have specific
   behaviors prescribed for them.  For UUIDv6, such requirements are
   relaxed.  Implementations may choose to continue to using the
   previous behavior, or refer to the sections on (TODO, links)
   Monotonicity and Collision Resistance and implement appropriate
   behavior described therein.

4.2.  Creating a UUIDv6 Value

   This section details a function in C which converts from a UUID
   version 1 to version 6:

   #include <stdio.h>
   #include <stdint.h>
   #include <inttypes.h>
   #include <arpa/inet.h>
   #include <uuid/uuid.h>

   /* Converts UUID version 1 to version 6 in place. */
   void uuidv1tov6(uuid_t u) {

     uint64_t ut;
     unsigned char *up = (unsigned char *)u;

     // load ut with the first 64 bits of the UUID
     ut = ((uint64_t)ntohl(*((uint32_t*)up))) << 32;
     ut |= ((uint64_t)ntohl(*((uint32_t*)&up[4])));

     // dance the bit-shift...
     ut =
       ((ut >> 32) & 0x0FFF) | // 12 least significant bits
       (0x6000) | // version number
       ((ut >> 28) & 0x0000000FFFFF0000) | // next 20 bits
       ((ut << 20) & 0x000FFFF000000000) | // next 16 bits
       (ut << 52); // 12 most significant bits

     // store back in UUID
     *((uint32_t*)up) = htonl((uint32_t)(ut >> 32));
     *((uint32_t*)&up[4]) = htonl((uint32_t)(ut));

   }

                       Figure 2: UUIDv6 Function in C







Peabody & Davis          Expires 20 August 2022                 [Page 8]

Internet-Draft               new-uuid-format               February 2022


4.3.  Example of a UUIDv6 Value

   TODO: Show 1x UUIDv6 examples (and their respective UUIDv1
   counterpart?

   ------------------------------------
   field           bits    value
   -----------------------------------
   time_top          48    <Example>
   ver                4    0110b
   time_bottom       12    <Example>
   var                2    01b
   remaining_bytes   62    <Example>
   -----------------------------------
   total            128
   ------------------------------------
   final: <example_uuidv6_from_table_inputs>

                    Figure 3: UUIDv6 Example Test Vector

5.  UUID Version 7

5.1.  Format

   UUID version 7 is a time-ordered value intended to be simpler and
   more flexible than version 6.

   The length of a UUIDv7 value is variable with a default of 128 bits
   as per Section 7.3.

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           unix_ts_ms                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          unix_ts_ms           |            rand_a             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    var_ver    |            rand_b                             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                            rand_b                             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                   Figure 4: UUIDv7 Field and Bit Layout

   unix_ts_ms:
      48-bit big-endian unsigned number of milliseconds since midnight 1
      January 1970 UTC.  Follows the same rules as a UNIX timestamp,
      i.e. does not include leap seconds.



Peabody & Davis          Expires 20 August 2022                 [Page 9]

Internet-Draft               new-uuid-format               February 2022


   rand_a:
      16-bits pseudo-random data to provide uniquness as per
      Section 7.10

   var_ver:
      The 8-bit combined variant and version field with the value 0xE7
      as defined by Section 7.2.

   rand_b:
      The final 56-bits of pseudo-random data to provide uniquness as
      per Section 7.10 and Section 7.7.

5.2.  Creating a UUIDv7 Value

TODO: some C code here showing how to generate, including option for counter

                    Figure 5: UUIDv7 Function in C

5.3.  Example of a UUIDv7 Value

   TODO: Show a few UUIDv7 values with the field/value breakdown

   -------------------------------
   field      bits    value
   -------------------------------
   unix_ts_ms   48    <Example>
   rand_a       16    <Example>
   var_ver       8    0xE7
   rand_b       56    <Example>
   -------------------------------
   total        128
   -------------------------------
   final: <example_uuidv7_from_table_inputs>

                    Figure 6: UUIDv7 Example Test Vector

6.  UUID Version 8

6.1.  Format

   UUID version 8 provides a backward compatible UUID format which
   otherwise has no restrictions on format except that the variant bits
   and version bits be set to 0xE8 in octet 9 as defined in Section 7.2.

   The length of a UUIDv8 value is variable with a default of 128 bits
   as dictated by Section 7.3.





Peabody & Davis          Expires 20 August 2022                [Page 10]

Internet-Draft               new-uuid-format               February 2022


    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           custom_a                            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           custom_a                            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    var_ver    |           custom_b                            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           custom_b                            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                   Figure 7: UUIDv8 Field and Bit Layout

   custom_a:
      The first 64-bits of the layout that can be filled as an
      implementation sees fit.

   var_ver:
      The 8-bit combined variant and version field with the value 0xE8
      as defined by Section 7.2.

   custom_b:
      The final 56-bits of the layout immediatly following the var_var
      field to be filled as an implementation sees fit.

7.  UUID Concerns

   The minimum requirements for generating UUIDs are described in this
   document for each version.  Storing UUIDs requires only that the
   exact value is recorded.  Everything else is an implementation detail
   and up to the implementor to decide what is appropriate for a given
   implementation.  That being said, various relevant factors are
   covered below to help guide an implementor through the different
   tradeoffs among differing UUID implementations.

7.1.  Storing UUIDs, Opacity

   UUIDs SHOULD be treated as opaque values unless there is a good
   reason to do otherwise (i.e. implementations SHOULD NOT examine the
   bits in a UUID to whatever extent is possible.)

   As such, any storage mechanism capable of storing a series of bytes
   (minimum 9, maximum 64) is a valid storage mechanism for UUIDs.  If
   an implementation chooses to only support 128-bit UUIDs, then
   anything that can store 16 bytes is valid.  Implementations which
   store UUIDs are not required or advised to have an understanding of
   their contents.



Peabody & Davis          Expires 20 August 2022                [Page 11]

Internet-Draft               new-uuid-format               February 2022


   For applications which go against this advice and must inspect UUIDs,
   extracting the version number can be done by first examining the
   variant field at bits 64 and 65 for the values 1 and 0 respectively,
   and then extract the version from bits 48 through 51.  UUID versions
   7 and 8 can be identified by checking octet 9 for the values 0xE7 or
   0xE8 repspectively.  The version number can then be used to inspect
   the remainder of the UUID according to the specification for that
   version.  See Section 7.2 for more information on determining a UUID
   version based on the inspected variant bits.

   In the event that custom elements are required implementors SHOULD
   utilize UUIDv8.  Section 6

   UUIDs can be stored in binary form or as text, as appropriate for
   individual systems.  Storing as binary requires less space and may
   result in faster data access.  Storing as text requires more space
   but may require less translation if the resulting text form is to be
   used after retrieval and thus maybe simpler to implement.

7.2.  Variant and Version Fields

   For UUIDv6 the version and variant field placement from [RFC4122] are
   unchanged and a new version (0110 [6]) has been added.

   00000000-0000-6000-8000-000000000000
   00000000-0000-6000-9000-000000000000
   00000000-0000-6000-A000-000000000000
   00000000-0000-6000-B000-000000000000
   xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx

               Figure 8: UUIDv6 Version and Variante Examples

   M:  Version (0110 [6])

   N:  Variant (1000 [8], 1001 [9], 1010 [A] or 1011 [B]) are all valid
      values

   For UUID versions 7 and 8, the variant field has been incremented and
   the version field has been moved to the same octet as the variant.
   Since the bits of the variant remain in the same place as described
   in [RFC4122] but utilized the previously reserved value 111, this
   allows a UUID to simply define octect 9 as var_ver, and the values
   0xE7 and 0xE8 indicate UUID versions 7 and 8 respectively.








Peabody & Davis          Expires 20 August 2022                [Page 12]

Internet-Draft               new-uuid-format               February 2022


   00000000-0000-0000-E700-000000000000
   xxxxxxxx-xxxx-xxxx-NMxx-xxxxxxxxxxxx

   00000000-0000-0000-E800-000000000000
   xxxxxxxx-xxxx-xxxx-NMxx-xxxxxxxxxxxx

               Figure 9: UUIDv7 Version and Variant Examples

   N:  Variant (1110 [E])

   M:  Version (0111 [7] or 1000 [8])

   While this specification makes use of the unused variant bits of 111
   defined in [RFC4122], Section 4.1.1; the placement of the version
   within the same octet as the variant leaves room for a future
   variant.  As such the table below details the previous variant, new
   variant and new variant that is reserved for future definition.

    +------+------+------+------+------------------------------------+
    | Msb0 | Msb1 | Msb2 | Msb3 | Description                        |
    +------+------+------+------+------------------------------------+
    | 1    | 0    | x    | x    | The variant specified by [RFC4122] |
    +------+------+------+------+------------------------------------+
    | 1    | 1    | 1    | 0    | The variant specified in this      |
    |      |      |      |      | document.                          |
    +------+------+------+------+------------------------------------+
    | 1    | 1    | 1    | 1    | Reserved for future definition.    |
    +------+------+------+------+------------------------------------+

           Table 1: UUID Variant defined by this specification

7.3.  Length (Variable, 128-bit Default)

   The default UUID length is still 128-bits, 16 bytes.  Implementations
   SHOULD default to this.

   Implementations MAY choose to allow generation UUIDs of anywhere from
   9 to 64 bytes.  (TODO: decide if we want to elaborate on the various
   possible motivations for this here, e.g. shorter for better human
   use, longer for lower collision probability)

   Implementations that store UUIDs of variable length SHOULD support
   any length from 9 to 64 bytes (TODO: decide if this is the right
   range - less than 9 bytes and we lose the variant/version, and 64 is
   arbitrary but we should have some upper limit in case it has an
   impact on physical storage requirements)





Peabody & Davis          Expires 20 August 2022                [Page 13]

Internet-Draft               new-uuid-format               February 2022


   Variable length is optional and implementations MAY opt-out and only
   support 128-bits.

   Recommendation is for implementations to start defining UUID as an
   array of bytes (length + pointer or whatever language mechanism)
   instead of a fixed set of 16 bytes.

   TODO: I think we need a table in here that gives bit/byte lengths and
   collision probability.  So someone can look down the numbers and pick
   the one that is right for their app.

7.4.  Text Format

   The existing hex and dash format (8-4-4-4-12) is still valid.
   Shorter or longer values just omit or add hex characters (TODO: give
   some examples at different lengths)

   Crockford base32 is allowed also (TODO: briefly summarize reasons -
   shorter, more compact if UUIDs are stored as text, crockford
   version's benefits vs).

   TODO: Discuss how parsers can use the presence of '-' to determine if
   it's hex or crockford base32 format.

   Compatible parsers MUST support crockford base32 with or without
   padding, and allow a checksum part (verifyin the checksum is
   optional)

   Base32 text encoder SHOULD output crockford base32 values without
   padding or checksum by default.  The padding or checksum features MAY
   be used if warranted for a specific application.

7.5.  Sorting

   UUIDv6 and UUIDv7 are designed so that implementations that require
   sorting (e.g. database indexes) SHOULD sort as opaque raw bytes,
   without examining the contents at all.

   Implementations MAY implement more complex sorting rules for UUID
   versions 1 through 5 (or strictly speaking they MAY do this for any
   version, but shouldn't need to).

   One of the big benefits of time ordering is "index locality" - new
   values are near each other in the index and can much more easily be
   clustered together for better performance.  Real-world differences vs
   random data can be quite large.





Peabody & Davis          Expires 20 August 2022                [Page 14]

Internet-Draft               new-uuid-format               February 2022


7.6.  Timestamp Granularity

   Implementations SHOULD use the current timestamp to provide values
   that are time-ordered and continually increasing.

   It's okay to "fuzz" timestamp values here for various reasons
   (security, clock inaccuracy, etc.), there is no absolute guarantee
   about how close the clock value needs to be to actual time - that's
   implementation-specific.

   TODO: Give some examples

7.7.  Monotonicity and Counters

   (the old clock seq, can be optionally implemented, doesn't help that
   muc in distributed environment)

   Within UUIDv7 it can be said that "each value returned is greater
   than the last" due to the embedded counter.

   Implementations SHOULD return monotonic values where it is feasible.
   E.g. in a single library, effort should be made to return successive
   values that count up.

   Implemetnations can achieve monotonic sequencing with an emedded
   sequence counter, by waiting for the next clock tick, or by checking
   that in case of next value has same timestamp see that the random
   bytes part is greater than prior value and generate new random bytes
   and check again.  TODO: Describe trade offs of these approaches, but
   it's implemenatation-specific - no mandedated sequence counter.

   Provide a clear suggestion of a recommended way (e.g. something as
   simple as: "if next UUID is >= last, generate again until timestamp
   or random bytes provide a value that is higher" - maybe consider a
   max limit for cases where the system clock rolls back).

   The monotonicity properties of an particular UUID generator SHOULD
   stated in it's documentation.

7.8.  Global and Local Uniqueness

   Global uniquess is impossible to guarantee without shared knowledge.
   I.e. two systems cannot come up with two numbers completely
   independently without some possibility of collission UNLESS they
   agree on some mechanism to ensure uniqueness ahead of time (e.g. your
   numbers always end with ... and mine always end with... or whatever)





Peabody & Davis          Expires 20 August 2022                [Page 15]

Internet-Draft               new-uuid-format               February 2022


   RFC4122 tried to use MAC address as shared knowledge - it sort of
   worked but had problems (security issues with exposing MAC addresses
   defined in Section 9, guarantee of actual global uniqueness is
   questionable)

   TODO: mention that "shared knowledge" is intentionally not required
   for implementation and this is part of the design, but...

   So instead just decide if you need 100% guarantee of uniqueness.  If
   so, implement shared knowledge approach (see section below)

   If not, reduce probability of uniqueness to acceptable level for your
   application.

   It is okay if implementations only provide "local" uniqueness, e.g.
   unique within one database instance or cluster of machines - as long
   as the implementation A) states that and B) the value can be
   reasonably expected to remain only in that system.  I.e. don't use
   this unique-within-this-database UUID across databases and the docs
   need to state this.

   Implementations which do not know the uniqueness requirements of the
   final application and cannot implement shared knowledge should just
   be made as unique as possible and state that.

7.9.  Collision Resistance

   In the absence of shared knowledge, collisions cannot be fully
   prevented, only the probability reduced.

   TODO: Give the math and some examples.

   TODO: Variable length allows you to further reduce collision probably
   beyond 128-bits if needed.  If we give the math, then people can make
   their own decisions based on their app.

   v7 is time ordered for better index locality/database performance, v8
   has lower collision resistance, pick your poison.

7.10.  Unguessability

   Some applications acquire security benefits from generating values
   that cannot be predicted (this is related to collision resistance,
   but not the same thing).







Peabody & Davis          Expires 20 August 2022                [Page 16]

Internet-Draft               new-uuid-format               February 2022


   Implementations SHOULD utilize a cryptographically secure pseudo-
   random number generator (CSPRNG) provides values that are both
   difficult to predict ("unguessable") and have a low likelyhood of
   collision ("unique").

   Length is a factor too (TODO: link to wherever we list out
   probabilities)

7.11.  Shared Knowledge

   Means a pre-arranged agreement about how different systems or pieces
   of code will each produce different values.

   Examples: A section of the "random" part gets devoted to: database
   node number, MAC or IP address, manually entered ID, etc.  Or it
   could be something like the UUID generator in a database
   implementation simply checks to ensure the UUID is not in use before
   generating.  Regardless, the concept is that an implementation MAY
   just make up a rule that ensures uniqueness, at the cost of some
   guessability.

   Using a shared knowledge pattern with the same length of UUID
   increases guessability (the more bits that fit a known value or
   pattern, the easier a value is to guess).

   Shared knowledge solutions are okay and MAY be done as long as this
   is stated in the UUID implementation docs.

   TODO: Talk a bit about the cost of collision, e.g.
   https://github.com/uuid6/uuid6-ietf-draft/
   issues/36#issuecomment-903295070

   Mention that the reason this spec does not endorse any specific
   global registry is because if something goes wrong with it (like the
   fact that MAC addresses used to be more or less unique but with cloud
   computing and software network interfaces being commonplace that
   assumption changed) - in this case random data results in lower
   collision probability.  So basically we're saying: Global registries,
   aside from being inconvenient, can still have problems and thus the
   collision probability jumps way up above the random data approach -
   so let's not even bother.  If an application wants a "perfect,
   guaranteed unique" solution, it provide it within it's own
   application via shared knowledge.








Peabody & Davis          Expires 20 August 2022                [Page 17]

Internet-Draft               new-uuid-format               February 2022


7.12.  Documentation

   We say in various places that certain things should be stated in the
   implementation docs.  So we should probably have a list here... If
   you make a UUID implementation, provide a clear statement in the
   documentation about each of these points:

   1.  Timestamp granularity (v7 only)
   2.  Monotoncity (v7 only do the values always count up)
   3.  Uniqueness scope (are these values supposed to be globally unique
       or unique with a specific context, if so which context)
   4.  Shared knowledge system (if any)
   5.  Collision resistance math (use the table in this spec if it
       helps)
   6.  Unguessability (how strong is the random number generator for how
       many bits)

8.  IANA Considerations

   This document has no IANA actions.

9.  Security Considerations

   MAC addresses pose inherent security risks and MUST not be used
   within a UUID.  As such they have been strictly forbidden from time-
   based UUIDs within this specification.  Instead pseudo-random data
   SHOULD selected from a source with sufficient entropy to ensure
   guaranteed uniqueness among UUID generation.  See Section 7.10 for
   more information.

   Timestamps embedded in the UUID do pose a very small attack surface.
   The timestamp in conjunction with an embedded counter does signal the
   order of creation for a given UUID and it's corresponding data but
   does not define anything about the data itself or the application as
   a whole.  If UUIDs are required for use with any security operation
   within an application context in any shape or form then [RFC4122]
   UUIDv4 SHOULD be utilized.

10.  Acknowledgements

   The authors gratefully acknowledge the contributions of Ben Campbell,
   Ben Ramsey, Fabio Lima, Gonzalo Salgueiro, Martin Thomson, Murray S.
   Kucherawy, Rick van Rein, Rob Wilton, Sean Leonard, Theodore Y.
   Ts'o., Robert Kieffer, sergeyprokhorenko As well as all of those in
   the IETF community and on GitHub to who contributed to the
   discussions which resulted in this document.

11.  Normative References



Peabody & Davis          Expires 20 August 2022                [Page 18]

Internet-Draft               new-uuid-format               February 2022


   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/info/rfc2119>.

   [RFC4122]  Leach, P., Mealling, M., and R. Salz, "A Universally
              Unique IDentifier (UUID) URN Namespace", RFC 4122,
              DOI 10.17487/RFC4122, July 2005,
              <https://www.rfc-editor.org/info/rfc4122>.

12.  Informative References

   [LexicalUUID]
              Twitter, "A Scala client for Cassandra", commit f6da4e0,
              November 2012,
              <https://github.com/twitter-archive/cassie>.

   [Snowflake]
              Twitter, "Snowflake is a network service for generating
              unique ID numbers at high scale with some simple
              guarantees.", Commit b3f6a3c, May 2014,
              <https://github.com/twitter-
              archive/snowflake/releases/tag/snowflake-2010>.

   [Flake]    Boundary, "Flake: A decentralized, k-ordered id generation
              service in Erlang", Commit 15c933a, February 2017,
              <https://github.com/boundary/flake>.

   [ShardingID]
              Instagram Engineering, "Sharding & IDs at Instagram",
              December 2012, <https://instagram-engineering.com/
              sharding-ids-at-instagram-1cf5a71e5a5c>.

   [KSUID]    Segment, "K-Sortable Globally Unique IDs", Commit bf376a7,
              July 2020, <https://github.com/segmentio/ksuid>.

   [Elasticflake]
              Pearcy, P., "Sequential UUID / Flake ID generator pulled
              out of elasticsearch common", Commit dd71c21, January
              2015, <https://github.com/ppearcy/elasticflake>.

   [FlakeID]  Pawlak, T., "Flake ID Generator", Commit fcd6a2f, April
              2020, <https://github.com/T-PWK/flake-idgen>.

   [Sonyflake]
              Sony, "A distributed unique ID generator inspired by
              Twitter's Snowflake", Commit 848d664, August 2020,
              <https://github.com/sony/sonyflake>.



Peabody & Davis          Expires 20 August 2022                [Page 19]

Internet-Draft               new-uuid-format               February 2022


   [orderedUuid]
              Cabrera, IT., "Laravel: The mysterious "Ordered UUID"",
              January 2020, <https://itnext.io/laravel-the-mysterious-
              ordered-uuid-29e7500b4f8>.

   [COMBGUID] Tallent, R., "Creating sequential GUIDs in C# for MSSQL or
              PostgreSql", Commit 2759820, December 2020,
              <https://github.com/richardtallent/RT.Comb>.

   [ULID]     Feerasta, A., "Universally Unique Lexicographically
              Sortable Identifier", Commit d0c7170, May 2019,
              <https://github.com/ulid/spec>.

   [SID]      Chilton, A., "sid : generate sortable identifiers",
              Commit 660e947, June 2019,
              <https://github.com/chilts/sid>.

   [pushID]   Google, "The 2^120 Ways to Ensure Unique Identifiers",
              February 2015, <https://firebase.googleblog.com/2015/02/
              the-2120-ways-to-ensure-unique_68.html>.

   [XID]      Poitrey, O., "Globally Unique ID Generator",
              Commit efa678f, October 2020, <https://github.com/rs/xid>.

   [ObjectID] MongoDB, "ObjectId - MongoDB Manual",
              <https://docs.mongodb.com/manual/reference/method/
              ObjectId/>.

   [CUID]     Elliott, E., "Collision-resistant ids optimized for
              horizontal scaling and performance.", Commit 215b27b,
              October 2020, <https://github.com/ericelliott/cuid>.

Authors' Addresses

   Brad G. Peabody
   Email: brad@peabody.io


   Kyzer R. Davis
   Email: kydavis@cisco.com











Peabody & Davis          Expires 20 August 2022                [Page 20]
