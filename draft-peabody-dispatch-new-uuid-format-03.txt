



dispatch                                                    BGP. Peabody
Internet-Draft                                                          
Updates: 4122 (if approved)                                     K. Davis
Intended status: Standards Track                        23 February 2022
Expires: 27 August 2022


                            New UUID Formats
               draft-peabody-dispatch-new-uuid-format-02

Abstract

   This document presents three new Universally Unique Identifier (UUID)
   formats.

   A common case for modern applications is to create a unique
   identifier for use as a primary key in a database table.  This
   identifier usually implements an embedded timestamp that is sortable
   using the monotonic creation time in the most significant bits.  In
   addition the identifier is highly collision resistant, difficult to
   guess, and provides minimal security attack surfaces.  None of the
   existing UUID versions, including UUIDv1, fulfill each of these
   requirements in the most efficient possible way.  This document is a
   proposal to update [RFC4122] with three new UUID versions that
   address these concerns, each with different trade-offs.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 27 August 2022.

Copyright Notice

   Copyright (c) 2022 IETF Trust and the persons identified as the
   document authors.  All rights reserved.




Peabody & Davis          Expires 27 August 2022                 [Page 1]

Internet-Draft               new-uuid-format               February 2022


   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Revised BSD License text as
   described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Revised BSD License.

Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3
   2.  Terminology . . . . . . . . . . . . . . . . . . . . . . . . .   4
     2.1.  Requirements Language . . . . . . . . . . . . . . . . . .   5
     2.2.  Abbreviations . . . . . . . . . . . . . . . . . . . . . .   5
   3.  Summary of Changes  . . . . . . . . . . . . . . . . . . . . .   5
     3.1.  changelog . . . . . . . . . . . . . . . . . . . . . . . .   5
   4.  Format  . . . . . . . . . . . . . . . . . . . . . . . . . . .   7
     4.1.  Variant and Version Fields  . . . . . . . . . . . . . . .   7
     4.2.  UUID Version 6  . . . . . . . . . . . . . . . . . . . . .   9
     4.3.  UUID Version 7  . . . . . . . . . . . . . . . . . . . . .  11
     4.4.  UUID Version 8  . . . . . . . . . . . . . . . . . . . . .  12
   5.  UUID Best Practices . . . . . . . . . . . . . . . . . . . . .  13
     5.1.  Timestamp Granularity . . . . . . . . . . . . . . . . . .  13
     5.2.  Monotonicity and Counters . . . . . . . . . . . . . . . .  14
     5.3.  Distributed UUID Generation . . . . . . . . . . . . . . .  16
     5.4.  Collision Resistance  . . . . . . . . . . . . . . . . . .  17
     5.5.  Global and Local Uniqueness . . . . . . . . . . . . . . .  17
     5.6.  Unguessability  . . . . . . . . . . . . . . . . . . . . .  17
     5.7.  Sorting . . . . . . . . . . . . . . . . . . . . . . . . .  18
     5.8.  Text Format . . . . . . . . . . . . . . . . . . . . . . .  18
     5.9.  Storing UUIDs, Opacity  . . . . . . . . . . . . . . . . .  18
   6.  Documentation . . . . . . . . . . . . . . . . . . . . . . . .  19
   7.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  19
   8.  Security Considerations . . . . . . . . . . . . . . . . . . .  19
   9.  Acknowledgements  . . . . . . . . . . . . . . . . . . . . . .  20
   10. Normative References  . . . . . . . . . . . . . . . . . . . .  20
   11. Informative References  . . . . . . . . . . . . . . . . . . .  20
   Appendix A.  Example Code . . . . . . . . . . . . . . . . . . . .  22
     A.1.  Creating a UUIDv6 Value . . . . . . . . . . . . . . . . .  22
     A.2.  Creating a UUIDv7 Value . . . . . . . . . . . . . . . . .  22
     A.3.  Creating a UUIDv7 Value . . . . . . . . . . . . . . . . .  23
   Appendix B.  Test Vectors . . . . . . . . . . . . . . . . . . . .  23
     B.1.  Example of a UUIDv6 Value . . . . . . . . . . . . . . . .  24
     B.2.  Example of a UUIDv7 Value . . . . . . . . . . . . . . . .  25
     B.3.  Example of a UUIDv8 Value . . . . . . . . . . . . . . . .  25
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  26




Peabody & Davis          Expires 27 August 2022                 [Page 2]

Internet-Draft               new-uuid-format               February 2022


1.  Introduction

   Many things have changed in the time since UUIDs were originally
   created.  Modern applications have a need to create and utilize UUIDs
   as the primary identifier for a variety of different items in complex
   computational systems, including but not limited to database primary
   keys, file names, machine or system names, identifiers for
   transactions or other objects or processes.

   A specific use case for UUIDs which has gained popularity is as
   database primary keys.  The motivation for this stems primarily from
   the fact that applications are increasingly distributed in nature.
   Simplistic "auto increment" schemes with integers in sequence do not
   work well in a distributed system since the effort required to
   synchronize such numbers across a network can easily become a burden.
   The fact that UUIDs can be used to create unique and reasonably short
   values in distributed systems without requiring synchronization makes
   them a good candidate for use as a database key in such environments.

   UUID versions 1 through 5 lack certain desirable characteristics in
   some circumstances:

   1.  Non-time-ordered UUID versions such as UUIDv4 have poor database
       index locality.  Meaning new values created in succession are not
       close to each other in the index and thus require inserts to be
       performed at random locations.  The negative performance effects
       of which on common structures used for this (B-tree and its
       variants) can be dramatic.

   2.  The 100-nanosecond, Gregorian epoch used in UUIDv1 timestamps is
       uncommon and difficult to represent accurately using a standard
       number format such as [IEEE754].

   3.  Introspection/parsing is required to order by time sequence; as
       opposed to being able to perform a simple byte-by-byte
       comparison.

   4.  Privacy and network security issues arise from using a MAC
       address in the node field of Version 1 UUIDs.  Exposed MAC
       addresses can be used as an attack surface to locate machines and
       reveal various other information about such machines (minimally
       manufacturer, potentially other details).  Additionally, with the
       advent of virtual machines and containers, MAC address uniqueness
       is no longer guaranteed.







Peabody & Davis          Expires 27 August 2022                 [Page 3]

Internet-Draft               new-uuid-format               February 2022


   5.  Many implementation details are specified in [RFC4122] but some
       of the decisions made involve trade offs that are neither
       possible to specify for all applications nor necessary to produce
       interoperable implementations.

   6.  The previous specification also does not distinguish between the
       requirements for generation of a UUID versus an application which
       simply stores one, which are different.

   Due to the aforementioned issue, many widely distributed database
   applications and large application vendors have sought to solve the
   problem of creating a better time-based, sortable unique identifier
   for use as a database key.  This has lead to numerous implementations
   over the past 10+ years solving the same problem in slightly
   different ways.

   While preparing this specification the following 16 different
   implementations were analyzed for trends in total ID length, bit
   Layout, lexical formatting/encoding, timestamp type, timestamp
   format, timestamp accuracy, node format/components, collision
   handling and multi-timestamp tick generation sequencing.

   1.   [ULID] by A.  Feerasta
   2.   [LexicalUUID] by Twitter
   3.   [Snowflake] by Twitter
   4.   [Flake] by Boundary
   5.   [ShardingID] by Instagram
   6.   [KSUID] by Segment
   7.   [Elasticflake] by P.  Pearcy
   8.   [FlakeID] by T.  Pawlak
   9.   [Sonyflake] by Sony
   10.  [orderedUuid] by IT.  Cabrera
   11.  [COMBGUID] by R.  Tallent
   12.  [SID] by A.  Chilton
   13.  [pushID] by Google
   14.  [XID] by O.  Poitrey
   15.  [ObjectID] by MongoDB
   16.  [CUID] by E.  Elliott

   An inspection of these implementations and the issues described above
   has led to this document which attempts to adapt UUIDs to address
   these issues.

2.  Terminology







Peabody & Davis          Expires 27 August 2022                 [Page 4]

Internet-Draft               new-uuid-format               February 2022


2.1.  Requirements Language

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in BCP
   14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.

2.2.  Abbreviations

   The following abbreviations are used in this document:

   UUID          Universally Unique Identifier [RFC4122]

   CSPRNG        Cryptographically Secure Pseudo-Random Number Generator

   MAC           Media Access Control

   MSB           Most Significant Bit

3.  Summary of Changes

   The following UUIDs are hereby introduced:

   1.  UUID version 6: A re-ordering of UUID version 1 so it is sortable
       as an opaque sequence of bytes.  Easy to implement given an
       existing UUIDv1 implementation.  See Section 4.2
   2.  UUID version 7: An entirely new time-based UUID bit layout
       sourced from the widely implemented and well known Unix Epoch
       timestamp source.  See Section 4.3
   3.  UUID version 8: A free-form UUID format which has no explicit
       requirements except maintaining backward compatibility.  See
       Section 4.4

3.1.  changelog

   RFC EDITOR PLEASE DELETE THIS SECTION.

   draft-03

      - Reworked the draft body to make the content more concise
      - UUIDv6 section reworked to just the reorder of the timestamp
      - UUIDv7 changed to simplify timestamp mechanism to just
      millisecond unix timestamp
      - UUIDv8 relaxed to be custom in all elements except version and
      variant
      - Changed UUIDv7 and UUIDv8 to use Variant 111.
      - Added C code samples for UUIDv6 and UUIDv7 in Appendix.



Peabody & Davis          Expires 27 August 2022                 [Page 5]

Internet-Draft               new-uuid-format               February 2022


      - Added test vectors for UUIDv6 and UUIDv7 in Appendix.
      - Version and Variant section combined into Variant and Version
      Fields section.
      - Changed from pseudo-random number generators to
      cryptographically secure pseudo-random number generator (CSPRNG).
      - Split Encoding and Storage section into more sections: Text
      Format and Storing UUIDs, Opacity
      - Reworked Global Uniqueness under new section Global and Local
      Uniqueness
      - Distributed UUID Generation section replaced with Shared
      Knowledge section
      - Combined redundant topics from all UUIDs into sections such as
      Sorting, Monotonicity and Counters, Collision Resistance, and
      Unguessability
      - Node verbiage only used in UUIDv6 and v7 and v8 reference random
      instead
      - Clock sequence verbiage changed simply to counter in any section
      other than UUIDv6
      - Added Abbreviations section

   draft-02

      - Added Changelog
      - Fixed misc. grammatical errors
      - Fixed section numbering issue
      - Fixed some UUIDvX reference issues
      - Changed all instances of "motonic" to "monotonic"
      - Changed all instances of "#-bit" to "# bit"
      - Changed "proceeding" verbiage to "after" in section 7
      - Added details on how to pad 32 bit unix timestamp to 36 bits in
      UUIDv7
      - Added details on how to truncate 64 bit unix timestamp to 36
      bits in UUIDv7
      - Added forward reference and bullet to UUIDv8 if truncating 64
      bit Unix Epoch is not an option.
      - Fixed bad reference to non-existent "time_or_node" in section
      4.5.4

   draft-01

      - Complete rewrite of entire document.
      - The format, flow and verbiage used in the specification has been
      reworked to mirror the original RFC 4122 and current IETF
      standards.
      - Removed the topics of UUID length modification, alternate UUID
      text formats, and alternate UUID encoding techniques.





Peabody & Davis          Expires 27 August 2022                 [Page 6]

Internet-Draft               new-uuid-format               February 2022


      - Research into 16 different historical and current
      implementations of time-based universal identifiers was completed
      at the end of 2020 in attempt to identify trends which have
      directly influenced design decisions in this draft document
      (https://github.com/uuid6/uuid6-ietf-draft/tree/master/research)
      - Prototype implementation have been completed for UUIDv6, UUIDv7,
      and UUIDv8 in various languages by many GitHub community members.
      (https://github.com/uuid6/prototypes)

4.  Format

   The UUID format is 16 octets; some bits of the eight octet variant
   field specified below determine finer structure.

4.1.  Variant and Version Fields

   The variant bits utilized by UUIDs in this specification remain in
   the same octet as originally defined by [RFC4122], Section 4.1.1.

   For UUIDv6 the version and variant field placement from [RFC4122] are
   unchanged and a new version (0110b [6]) has been added.

   00000000-0000-6000-8000-000000000000
   00000000-0000-6000-9000-000000000000
   00000000-0000-6000-A000-000000000000
   00000000-0000-6000-B000-000000000000
   xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx

               Figure 1: UUIDv6 Version and Variant Examples

   M:  Version (0110b [6])

   N:  Variant (1000b [8], 1001b [9], 1010b [A] or 1011b [B]) are all
      valid values

   For UUID versions 7 and 8, the variant field has been incremented and
   the version field has been moved to the same octet as the variant.
   Since the bits of the variant remain in the same place as described
   in [RFC4122] but utilized the previously reserved value 111, this
   allows a UUID to simply define octet 8 as var_ver, and the values
   0xE7 and 0xE8 indicate UUID versions 7 and 8 respectively.

   00000000-0000-0000-E700-000000000000
   xxxxxxxx-xxxx-xxxx-NMxx-xxxxxxxxxxxx

   00000000-0000-0000-E800-000000000000
   xxxxxxxx-xxxx-xxxx-NMxx-xxxxxxxxxxxx




Peabody & Davis          Expires 27 August 2022                 [Page 7]

Internet-Draft               new-uuid-format               February 2022


               Figure 2: UUIDv7 Version and Variant Examples

   N:  Variant (1110b [E])

   M:  Version (0111b [7] or 1000 [8])

   While this specification makes use of the unused variant bits of 111
   defined in [RFC4122], Section 4.1.1; the placement of the version
   within the same octet as the variant leaves room for a future
   variant.

   UUID Version 7 and 8 specified by this document MUST set the first 3
   bits of octet 8 to 111 and the fourth bit to 0.  The 4 bit version
   MUST follow the variant to fill out the final bits of octet 8.

   Future specifications that wish to utilize variant 111 for a
   different version position (or any other bit layout position) MUST
   set the first 3 bits of octet 8 to 111 and then the fourth bit to 1.

   As such the tables below detail the three variants and versions
   described in this document where the letter "x" indicates a
   "don't-care" value.

    +------+------+------+------+-------------------------------------+
    | Msb0 | Msb1 | Msb2 | Msb3 | Description                         |
    +------+------+------+------+-------------------------------------+
    | 1    | 0    | x    | x    | The variant specified by [RFC4122]. |
    |      |      |      |      | Hex characters 8, 9, A, B.          |
    +------+------+------+------+-------------------------------------+
    | 1    | 1    | 1    | 0    | The variant specified in this       |
    |      |      |      |      | document.  Hex character E,         |
    +------+------+------+------+-------------------------------------+
    | 1    | 1    | 1    | 1    | Reserved for future definition.     |
    |      |      |      |      | Hex Character F.                    |
    +------+------+------+------+-------------------------------------+

            Table 1: UUID Variant defined by this specification














Peabody & Davis          Expires 27 August 2022                 [Page 8]

Internet-Draft               new-uuid-format               February 2022


       +------+------+------+------+---------+---------------------+
       | Msb0 | Msb1 | Msb2 | Msb3 | Version | Description         |
       +------+------+------+------+---------+---------------------+
       | 0    | 1    | 1    | 0    | 6       | Reordered Gregorian |
       |      |      |      |      |         | time-based UUID     |
       +------+------+------+------+---------+---------------------+
       | 0    | 1    | 1    | 1    | 7       | Unix Epoch time-    |
       |      |      |      |      |         | based UUID          |
       +------+------+------+------+---------+---------------------+
       | 1    | 0    | 0    | 0    | 8       | Custom UUID         |
       +------+------+------+------+---------+---------------------+

            Table 2: UUID versions defined by this specification

4.2.  UUID Version 6

   UUID version 6 is a field-compatible version of UUIDv1, reordered for
   improved DB locality.  It is expected that UUIDv6 will primarily be
   used in contexts where there are existing v1 UUIDs.  Systems that do
   not involve legacy UUIDv1 SHOULD consider using UUIDv7 instead.

   Instead of splitting the timestamp into the low, mid and high
   sections from UUIDv1, UUIDv6 changes this sequence so timestamp bytes
   are stored from most to least significant.  That is, given a 60 bit
   timestamp value as specified for UUIDv1 in [RFC4122], Section 4.1.4,
   for UUIDv6, the first 48 most significant bits are stored first,
   followed by the 4 bit version (same position), followed by the
   remaining 12 bits of the original 60 bit timestamp.

   The clock sequence bits remain unchanged from their usage and
   position in [RFC4122], Section 4.1.5.

   The 48 bit node SHOULD be set to a pseudo-random value however
   implementations MAY choose retain the old MAC address behavior from
   [RFC4122], Section 4.1.6 and [RFC4122], Section 4.5.  For more
   information on MAC address usage within UUIDs see the Section 8

   The format for the 16-byte, 128 bit UUIDv6 is shown in Figure 1













Peabody & Davis          Expires 27 August 2022                 [Page 9]

Internet-Draft               new-uuid-format               February 2022


        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                           time_high                           |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |           time_mid            |      time_low_and_version     |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |clk_seq_hi_res |  clk_seq_low  |         node (0-1)            |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                         node (2-5)                            |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                   Figure 3: UUIDv6 Field and Bit Layout

   time_high:
      The most significant 32 bits of the 60 bit starting timestamp.
      Occupies bits 0 through 31 (octets 0-3)

   time_mid:
      The middle 16 bits of the 60 bit starting timestamp.  Occupies
      bits 32 through 47 (octets 4-5)

   time_low_and_version:
      The first four most significant bits MUST contain the UUIDv6
      version (0110) while the remaining 12 bits will contain the least
      significant 12 bits from the 60 bit starting timestamp.  Occupies
      bits 48 through 63 (octets 6-7)

   clk_seq_hi_res:
      The first two bits MUST be set to the UUID variant (10) The
      remaining 6 bits contain the high portion of the clock sequence.
      Occupies bits 64 through 71 (octet 8)

   clock_seq_low:
      The 8 bit low portion of the clock sequence.  Occupies bits 72
      through 79 (octet 9)

   node:
      48 bit spatially unique identifier Occupies bits 80 through 127
      (octets 10-15)

   With UUIDv6 the steps for splitting the timestamp into time_high and
   time_mid are optional since the 48 bits of time_high and time_mid
   will remain in the same order.  An extra step of splitting the first
   48 bits of the timestamp into the most significant 32 bits and least
   significant 16 bits proves useful when reusing an existing UUIDv1
   implementation.  In which the following logic can be applied to
   reshuffle the bits with minimal modifications.



Peabody & Davis          Expires 27 August 2022                [Page 10]

Internet-Draft               new-uuid-format               February 2022


                  +--------------+------+--------------+
                  | UUIDv1 Field | Bits | UUIDv6 Field |
                  +--------------+------+--------------+
                  | time_low     | 32   | time_high    |
                  +--------------+------+--------------+
                  | time_mid     | 16   | time_mid     |
                  +--------------+------+--------------+
                  | time_high    | 12   | time_low     |
                  +--------------+------+--------------+

                     Table 3: UUIDv1 to UUIDv6 Field
                                 Mappings

4.3.  UUID Version 7

   UUID version 7 features a time-ordered value field derived from the
   widely implemented and well known Unix Epoch timestamp source, as
   well as improved entropy characteristics over versions 1 or 6.
   Implementations SHOULD utilize UUID version 7 over UUID version 1 and
   6 if possible.

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           unix_ts_ms                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      unix_ts_ms       |                  rand_a               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    var_ver    |            rand_b                             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                            rand_b                             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                   Figure 4: UUIDv7 Field and Bit Layout

   unix_ts_ms:
      44 bit big-endian unsigned number of milliseconds since midnight 1
      January 1970 UTC.  Follows the same rules as a UNIX timestamp,
      i.e. does not include leap seconds.

   rand_a:
      20 bits pseudo-random data to provide uniqueness as per
      Section 5.6

   var_ver:
      The 8 bit combined variant and version field with the value 0xE7
      as defined by Section 4.1.




Peabody & Davis          Expires 27 August 2022                [Page 11]

Internet-Draft               new-uuid-format               February 2022


   rand_b:
      The final 56 bits of pseudo-random data to provide uniqueness as
      per Section 5.6 and Section 5.2.

4.4.  UUID Version 8

   UUID version 8 provides an RFC-compatible format for experimental or
   vendor-specific use cases.  The only requirement is that the variant
   and version bits MUST be set as defined in Section 4.1.  UUIDv8's
   uniqueness will be implementation-specific and should not be assumed.

   UUIDv8 SHOULD only be utilized if an implementation cannot utilize
   another UUID in this document or [RFC4122].

   The only explicitly defined bits are the Version and Variant leaving
   120 bits for implementation specific time-based UUIDs.  To be clear:
   UUIDv8 is not a replacement for UUIDv4 where all 122 extra bits are
   filled with random data.

   Some example situations in which UUIDv8 usage could occur:

   *  An implementation would like to embed extra information within the
      UUID other than what is defined in this document.

   *  An implementation has other application/language restrictions
      which inhibit the use of one of the current UUIDs.

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           custom_a                            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           custom_a                            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    var_ver    |           custom_b                            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           custom_b                            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                   Figure 5: UUIDv8 Field and Bit Layout

   custom_a:
      The first 64 bits of the layout that can be filled as an
      implementation sees fit.

   var_ver:
      The 8 bit combined variant and version field with the value 0xE8
      as defined by Section 4.1.



Peabody & Davis          Expires 27 August 2022                [Page 12]

Internet-Draft               new-uuid-format               February 2022


   custom_b:
      The final 56 bits of the layout immediatly following the var_var
      field to be filled as an implementation sees fit.

5.  UUID Best Practices

   The minimum requirements for generating UUIDs are described in this
   document for each version.  Storing UUIDs requires only that the
   exact value is recorded.  Everything else is an implementation detail
   and up to the implementer to decide what is appropriate for a given
   implementation.  That being said, various relevant factors are
   covered below to help guide an implementer through the different
   trade-offs among differing UUID implementations.

5.1.  Timestamp Granularity

   UUID timestamp source, precision and length are the topic of great
   debate while creating this specification.  As such choosing the right
   timestamp for your application is a very important topic.  This
   section will detail some of the common points on this topic.

   Implementations SHOULD use the current timestamp from a reliable
   source to provide values that are time-ordered and continually
   increasing.  Care SHOULD be taken to ensure the timestamp does not
   move backwards which will impact UUID sorting.


   Source:
      UUID version 1 and 6 both utilize a Gregorian epoch timestamp
      while UUIDv7 utilizes a Unix Epoch timestamp.  If other timestamp
      sources or a custom timestamp epoch are required UUIDv8 SHOULD be
      leveraged.

   Sub-second Precision:
      Many levels of precision exist for timestamps: milliseconds,
      microseconds, nanoseconds, and beyond.  Additionally fractional
      representations of sub-second precision may be desired to create
      more exotic timestamps.  With UUID version 1 and 6,
      100-nanoseconds of precision are present in the selected timestamp
      while UUIDv7 features fixed millisecond level of precision within
      the Unix epoch.  If additional levels of precision are required
      UUIDv8 SHOULD be utilized.









Peabody & Davis          Expires 27 August 2022                [Page 13]

Internet-Draft               new-uuid-format               February 2022


   Length:
      The length of a given timestamp directly impacts how long a given
      UUID will be valid.  Care should be given to ensure that the
      proper length is selected for a given timestamp.  UUID version 1
      and 6 utilize a 60 bit timestamp and UUIDv7 features a 48 bit
      timestamp.

   Implementations MAY fuzz a timestamp.  Some examples included
   security considerations around providing a real clock value within a
   UUID or to correct inaccurate clocks.  This specification makes no
   requirement or guarantee about how close the clock value needs to be
   to actual time.

   When timestamp padding is required, implementations MUST pad the most
   significant bits (left-most) bits with zeros.  An example is padding
   the most significant, left-most bits of a 32 bit unix timestamp with
   zero's to fill out the 48 bit timestamp in UUIDv7.

   Similarly, when timestamps need to be truncated: the lower, least
   significant bits MUST be used.  An example would be truncating a 64
   bit unix timestamp to the least significant, right-most 48 bits for
   UUIDv7.

5.2.  Monotonicity and Counters

   Monotonicity is the backbone of time-based sortable UUIDs.  Time-
   based UUIDs from this document should leverage monotonicity within
   the timestamp as per Section 5.1.

   Additional care MUST be taken to ensure UUIDs generated in batches
   are also monotonic.  That is, if 1000 UUIDs are generated for the
   same timestamp; there is sufficient logic for organizing the creation
   of order of those 1000 UUIDs.  For batch UUID creation it is common
   to employ a monotonic counter which SHOULD increment for each UUID
   created during a given timestamp.  This section will discuss the
   common approaches to solving this problem for a single node
   generating UUIDs.  For Distributed Nodes please refer to Section 5.3

   For single-node UUID implementations that do not need to create
   batches of UUIDs, the embedded timestamp within UUID version 1, 6,
   and 7 can provide sufficient monotonicity guarantees by simply
   ensuring that timestamp increments before creating a new UUID.

   For single-node UUID implementations that do require batch UUID
   creation, one of the following methods SHOULD be employed:






Peabody & Davis          Expires 27 August 2022                [Page 14]

Internet-Draft               new-uuid-format               February 2022


   Dedicated Counter Bits:
      This references the practice of allocating a specific number of
      bits in the UUID layout to the sole purpose of tallying the total
      number of UUIDs created during a given UUID timestamp tick.
      Positioning of a fixed bit-length counter SHOULD be immediatly
      after the embedded timestamp.  This promotes sortability and
      allows random data generation for each counter increment.  An
      alternative approach to this method is to dedicate a number of
      bits in the least significant position of the UUID.  With this
      alternative method, the random data MUST be frozen for a given
      timestamp tick else sorting will be impacted.  Implementations
      utilizing fixed-length counter bits SHOULD initialize the counter
      at zero to ensure the full bit-space is utilized and help avoid
      counter rollovers.  Care MUST be taken to select a counter bit-
      length that can properly handle the level of timestamp precision
      in use.  For example, millisecond precision SHOULD require a
      larger counter than a timestamp with nanosecond precision.
      Counter rollovers SHOULD be handled by the application and are out
      of the scope of this document.  If dedicated counter bits are
      required implementations SHOULD utilize UUIDv8.

   Monotonic Random:
      With this method the random data is extended to also double as a
      counter.  This monotonic random can be thought of as a "randomly
      seeded counter" which MUST be incremented in the least significant
      position for each UUID created on a given timestamp tick.  This is
      similar to the alternative method described in the previous bullet
      but does not suffer from rollover issues plagued by fixed-length
      bit fields.  UUIDv7 utilizes this method to handle batch UUID
      generation during a single timestamp tick.

   Implementations can use the following logic to ensure UUIDs featuring
   embedded counters are monotonic in nature:

   1.  Compare the current timestamp against the previously stored
       timestamp.
   2.  If the current timestamp is equal to the previous timestamp;
       increment desired counter logic.
       If the current timestamp is greater than the previous timestamp;
       re-initialize the counter to the new timestamp and generate new
       random bytes (if the bytes were frozen or being used as the seed
       for a monotonic counter.).









Peabody & Davis          Expires 27 August 2022                [Page 15]

Internet-Draft               new-uuid-format               February 2022


   Implementations SHOULD check if the the currently generated UUID is
   greater than the previously generated UUID.  If this is not the case
   then any number of things could have occurred.  Such as, but not
   limited to, clock rollbacks or counter rollovers.  Applications
   SHOULD embed sufficient logic to catch these scenarios and correct
   the problem ensuring the next UUID generated is greater than the
   previous.

5.3.  Distributed UUID Generation

   Some implementations MAY desire to utilize multi-node, clustered,
   applications which involve 2 or more applications independently
   generating UUIDs that will be stored in a common location.  While
   UUIDs already feature sufficient entropy to ensure that the chances
   of collision are low as the total number of nodes increase; so does
   the likelihood of a collision.  This section will detail the
   approaches that MAY be utilized by multi-node UUID implementations in
   distributed environments.

   Shared Knowledge System:
      With this method all nodes tasked with creating UUIDs consult a
      central registry and confirm the generated value is unique.  As
      applications scale the communication with the central registry
      could become a bottleneck and impact UUID generation in a negative
      way.  Utilization of shared knowledge schemes with central/global
      registries is outside the scope of this specification.  Machine
      IDs, discussed in the next bullet, SHOULD be used in place of
      shared knowledge systems.

   Machine IDs:
      With this method, a nondescript pseudo-random Machine ID value is
      placed within the UUID layout.  This machine id ensures the bit-
      space for a given node is unique resulting in UUIDs that do not
      conflict with any other UUID created by another node with a
      different machine id.  Implementations that choose to leverage an
      embedded machine id SHOULD utilize UUIDv8.  The machine id SHOULD
      NOT be an IEEE 802 MAC address as per Section 8.  The location and
      bit length are up to implements and outside the scope of this
      specification.  Furthermore, the creation and negotiation of a
      machine id among distributed nodes is also out of scope for this
      specification.

   Utilization of either a shared knowledge scheme or Machine are not
   required for implementing UUIDs in this specification.  However
   implementations SHOULD utilize one of the two aforementioned methods
   if distributed UUID generation is a requirements.





Peabody & Davis          Expires 27 August 2022                [Page 16]

Internet-Draft               new-uuid-format               February 2022


5.4.  Collision Resistance

   Implementations SHOULD weigh the importance of a collision within
   their application and take this into account when making a selections
   around the total entropy (random) to dedicated to a UUID layout
   versus the other components such as Section 5.1 and Section 5.2.
   This is especially true for distributed node collision resistance as
   defined by Section 5.3.

   There are three example scenarios below which help illustrate the
   varying seriousness of a collision within an application.

   Low Impact
      A UUID collision generated a duplicate log entry which results in
      incorrect statistics derived from the data.  Implementations that
      are not negatively affected by collisions may continue with the
      entropy and uniqueness provided by the traditional UUID format.

   High Impact:
      A duplicate key causes an airplane to receive the wrong course
      which puts people's lives at risk.  In this scenario there is no
      margin for error.  Collisions MUST be avoided and failure is
      unacceptable.  As such applications dealing with this type of
      scenario MUST employ as much collision resistance as possible
      within the given application context.

5.5.  Global and Local Uniqueness

   UUIDs created by this specification MAY be used to provide local
   uniqueness guarantees.  For example, ensuring UUIDs created within a
   local application context are unique within a database MAY be
   sufficient for some implementations where global uniqueness outside
   of the application context, in other applications, or around the
   world is not required.

   Although true global uniqueness is impossible to guarantee without
   shared knowledge scheme; a shared knowledge scheme is not required by
   UUID to provide uniqueness guarantees.  Implementations MAY implement
   a shared knowledge scheme as they see fit to extend the uniqueness
   guaranteed this specification and [RFC4122].

5.6.  Unguessability

   Implementations SHOULD utilize a cryptographically secure pseudo-
   random number generator (CSPRNG) to provide values that are both
   difficult to predict ("unguessable") and have a low likelihood of
   collision ("unique").  CSPRNG ensures the best of Section 5.4 and
   Section 8 are present in modern UUIDs.



Peabody & Davis          Expires 27 August 2022                [Page 17]

Internet-Draft               new-uuid-format               February 2022


5.7.  Sorting

   UUIDv6 and UUIDv7 are designed so that implementations that require
   sorting (e.g. database indexes) SHOULD sort as opaque raw bytes,
   without examining the contents at all.

   Time ordered monotonic UUIDs benefit from grater index locality
   because the new values are near each other in the index.  As a result
   objects can much more easily be clustered together for better
   performance.  The real-world differences in this approach of index
   locality vs random data inserts can be quite large.

5.8.  Text Format

   The UUID length of 16 octets (128 bits) remains unchanged.  The
   textual representation of a UUID consisting of 36 hexadecimal and
   dash characters in the format 8-4-4-4-12 remains unchanged for human
   readability.

5.9.  Storing UUIDs, Opacity

   For many applications, such as databases, storing UUIDs as the text
   is unnecessarily verbose totaling 288 bits to convey a 128 bit UUID
   value.  Due to the this, where possible, UUIDs SHOULD be stored
   within database applications as the underlying 128 bit binary value.

   *  8 bits for each of the 32 hex characters = 256 bits
   *  8 bits for each of the 4 hyphens = 32 bits

   For other systems, UUIDs MAY be stored in binary form or as text, as
   appropriate.  The trade offs to both approaches are as such:

   *  Storing as binary requires less space and may result in faster
      data access.
   *  Storing as text requires more space but may require less
      translation if the resulting text form is to be used after
      retrieval and thus maybe simpler to implement.

   UUIDs SHOULD be treated as opaque values and implementations SHOULD
   NOT examine the bits in a UUID to whatever extent is possible.











Peabody & Davis          Expires 27 August 2022                [Page 18]

Internet-Draft               new-uuid-format               February 2022


   Where necessary, the version number may be extracted by first
   verifying the variant field bits 64 and 65 contain 1 and 0
   respectively, and then extract the version from bits 48 through 51.
   UUID versions 7 and 8 can be identified by checking octet 8 for the
   values 0xE7 or 0xE8 respectively.  The version number can then be
   used to inspect the remainder of the UUID according to the
   specification for that version.  See Section 4.1 for more information
   on determining a UUID version based on the inspected variant bits.

6.  Documentation

   We say in various places that certain things should be stated in the
   implementation docs.  So we should probably have a list here... If
   you make a UUID implementation, provide a clear statement in the
   documentation about each of these points:

   1.  Timestamp granularity (v7 only)
   2.  Monotoncity (v7 only do the values always count up)
   3.  Uniqueness scope (are these values supposed to be globally unique
       or unique with a specific context, if so which context)
   4.  Shared knowledge system (if any)
   5.  Collision resistance math (use the table in this spec if it
       helps)
   6.  Unguessability (how strong is the random number generator for how
       many bits)

7.  IANA Considerations

   This document has no IANA actions.

8.  Security Considerations

   MAC addresses pose inherent security risks and MUST not be used
   within a UUID.  As such they have been strictly forbidden from time-
   based UUIDs within this specification.  Instead pseudo-random data
   SHOULD selected from a source with sufficient entropy to ensure
   guaranteed uniqueness among UUID generation.  See Section 5.6 for
   more information.

   Timestamps embedded in the UUID do pose a very small attack surface.
   The timestamp in conjunction with an embedded counter does signal the
   order of creation for a given UUID and it's corresponding data but
   does not define anything about the data itself or the application as
   a whole.  If UUIDs are required for use with any security operation
   within an application context in any shape or form then [RFC4122]
   UUIDv4 SHOULD be utilized.





Peabody & Davis          Expires 27 August 2022                [Page 19]

Internet-Draft               new-uuid-format               February 2022


9.  Acknowledgements

   The authors gratefully acknowledge the contributions of Ben Campbell,
   Ben Ramsey, Fabio Lima, Gonzalo Salgueiro, Martin Thomson, Murray S.
   Kucherawy, Rick van Rein, Rob Wilton, Sean Leonard, Theodore Y.
   Ts'o., Robert Kieffer, sergeyprokhorenko As well as all of those in
   the IETF community and on GitHub to who contributed to the
   discussions which resulted in this document.

10.  Normative References

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/info/rfc2119>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/info/rfc8174>.

   [RFC4122]  Leach, P., Mealling, M., and R. Salz, "A Universally
              Unique IDentifier (UUID) URN Namespace", RFC 4122,
              DOI 10.17487/RFC4122, July 2005,
              <https://www.rfc-editor.org/info/rfc4122>.

11.  Informative References

   [LexicalUUID]
              Twitter, "A Scala client for Cassandra", commit f6da4e0,
              November 2012,
              <https://github.com/twitter-archive/cassie>.

   [Snowflake]
              Twitter, "Snowflake is a network service for generating
              unique ID numbers at high scale with some simple
              guarantees.", Commit b3f6a3c, May 2014,
              <https://github.com/twitter-
              archive/snowflake/releases/tag/snowflake-2010>.

   [Flake]    Boundary, "Flake: A decentralized, k-ordered id generation
              service in Erlang", Commit 15c933a, February 2017,
              <https://github.com/boundary/flake>.

   [ShardingID]
              Instagram Engineering, "Sharding & IDs at Instagram",
              December 2012, <https://instagram-engineering.com/
              sharding-ids-at-instagram-1cf5a71e5a5c>.




Peabody & Davis          Expires 27 August 2022                [Page 20]

Internet-Draft               new-uuid-format               February 2022


   [KSUID]    Segment, "K-Sortable Globally Unique IDs", Commit bf376a7,
              July 2020, <https://github.com/segmentio/ksuid>.

   [Elasticflake]
              Pearcy, P., "Sequential UUID / Flake ID generator pulled
              out of elasticsearch common", Commit dd71c21, January
              2015, <https://github.com/ppearcy/elasticflake>.

   [FlakeID]  Pawlak, T., "Flake ID Generator", Commit fcd6a2f, April
              2020, <https://github.com/T-PWK/flake-idgen>.

   [Sonyflake]
              Sony, "A distributed unique ID generator inspired by
              Twitter's Snowflake", Commit 848d664, August 2020,
              <https://github.com/sony/sonyflake>.

   [orderedUuid]
              Cabrera, IT., "Laravel: The mysterious "Ordered UUID"",
              January 2020, <https://itnext.io/laravel-the-mysterious-
              ordered-uuid-29e7500b4f8>.

   [COMBGUID] Tallent, R., "Creating sequential GUIDs in C# for MSSQL or
              PostgreSql", Commit 2759820, December 2020,
              <https://github.com/richardtallent/RT.Comb>.

   [ULID]     Feerasta, A., "Universally Unique Lexicographically
              Sortable Identifier", Commit d0c7170, May 2019,
              <https://github.com/ulid/spec>.

   [SID]      Chilton, A., "sid : generate sortable identifiers",
              Commit 660e947, June 2019,
              <https://github.com/chilts/sid>.

   [pushID]   Google, "The 2^120 Ways to Ensure Unique Identifiers",
              February 2015, <https://firebase.googleblog.com/2015/02/
              the-2120-ways-to-ensure-unique_68.html>.

   [XID]      Poitrey, O., "Globally Unique ID Generator",
              Commit efa678f, October 2020, <https://github.com/rs/xid>.

   [ObjectID] MongoDB, "ObjectId - MongoDB Manual",
              <https://docs.mongodb.com/manual/reference/method/
              ObjectId/>.

   [CUID]     Elliott, E., "Collision-resistant ids optimized for
              horizontal scaling and performance.", Commit 215b27b,
              October 2020, <https://github.com/ericelliott/cuid>.




Peabody & Davis          Expires 27 August 2022                [Page 21]

Internet-Draft               new-uuid-format               February 2022


   [IEEE754]  IEEE, "Collision-resistant ids optimized for horizontal
              scaling and performance.", Series 754-2019, July 2019,
              <https://standards.ieee.org/ieee/754/6210/>.

Appendix A.  Example Code

A.1.  Creating a UUIDv6 Value

   This section details a function in C which converts from a UUID
   version 1 to version 6:

   #include <stdio.h>
   #include <stdint.h>
   #include <inttypes.h>
   #include <arpa/inet.h>
   #include <uuid/uuid.h>

   /* Converts UUID version 1 to version 6 in place. */
   void uuidv1tov6(uuid_t u) {

     uint64_t ut;
     unsigned char *up = (unsigned char *)u;

     // load ut with the first 64 bits of the UUID
     ut = ((uint64_t)ntohl(*((uint32_t*)up))) << 32;
     ut |= ((uint64_t)ntohl(*((uint32_t*)&up[4])));

     // dance the bit-shift...
     ut =
       ((ut >> 32) & 0x0FFF) | // 12 least significant bits
       (0x6000) | // version number
       ((ut >> 28) & 0x0000000FFFFF0000) | // next 20 bits
       ((ut << 20) & 0x000FFFF000000000) | // next 16 bits
       (ut << 52); // 12 most significant bits

     // store back in UUID
     *((uint32_t*)up) = htonl((uint32_t)(ut >> 32));
     *((uint32_t*)&up[4]) = htonl((uint32_t)(ut));

   }

                       Figure 6: UUIDv6 Function in C

A.2.  Creating a UUIDv7 Value

TODO: some C code here showing how to generate, including option for counter

                    Figure 7: UUIDv7 Function in C



Peabody & Davis          Expires 27 August 2022                [Page 22]

Internet-Draft               new-uuid-format               February 2022


A.3.  Creating a UUIDv7 Value

   UUIDv8 will vary greatly from implementation to implementation.  A
   good candidate use case for UUIDv8 is to embed exotic timestamps like
   the one found in this example which employs approximately 0.25
   milliseconds and approximately 5 microseconds per timestamp tick as a
   48 bit value.

   #include <stdint.h>
   #include <stdio.h>
   #include <time.h>

   int main() {
     struct timespec tp;
     clock_gettime(CLOCK_REALTIME, &tp);
     uint64_t timestamp = (uint64_t)tp.tv_sec << 12;

     // compute 12-bit (~0.25 msec precision) fraction from nsecs
     timestamp |= ((uint64_t)tp.tv_nsec << 12) / 1000000000;

     printf("%08llx-%04llx\n", timestamp >> 16, timestamp & 0xFFFF);
     return 0;
   }

                       Figure 8: UUID8 Function in C

Appendix B.  Test Vectors

   Both UUIDv1 and UUIDv6 test vectors utilize the same 60-bit
   timestamp: 0x1EC9414C232AB00 (138648505420000000) Tuesday, February
   22, 2022 2:22:22.000000 PM GMT-05:00




















Peabody & Davis          Expires 27 August 2022                [Page 23]

Internet-Draft               new-uuid-format               February 2022


# Unix Nanosecond precision to Gregorian 100-nanosecond intervals
gregorian_100_ns = (unix_64_bit_nanoseconds / 100) + gregorian_unix_offset

# Gregorian to Unix Offset:
# The number of 100-ns intervals between the
# UUID epoch 1582-10-15 00:00:00 and the Unix epoch 1970-01-01 00:00:00.
# gregorian_unix_offset = 0x01b21dd213814000 or 122192928000000000

# Unix 64 bit Nanosecond Timestamp:
# Unix NS: Tuesday, February 22, 2022 2:22:22 PM GMT-05:00
# unix_64_bit_nanoseconds = 0x16D6320C3D4DCC00 or 1645557742000000000

# Work:
# gregorian_100_ns = (1645557742000000000 / 100) + 122192928000000000
# (138648505420000000 - 122192928000000000) * 100 = unix_64_bit_nanoseconds

# Final:
# gregorian_100_ns = 0x1EC9414C232AB00 or 138648505420000000

# Original: 000111101100100101000001010011000010001100101010101100000000
# UUIDv1:   11000010001100101010101100000000|1001010000010100|0001|000111101100
# UUIDv6:   00011110110010010100000101001100|0010001100101010|0110|101100000000

             Figure 9: Test Vector Timestamp Pseudo-code

B.1.  Example of a UUIDv6 Value

   ----------------------------------------------
   field                 bits    value_hex
   ----------------------------------------------
   time_low              32      0xC232AB00
   time_mid              16      0x9414
   time_hi_and_version   16      0x11EC
   clk_seq_hi_res         8      0x80
   clock_seq_low          8      0x00
   node                  48      0x9E6BDECED846
   ----------------------------------------------
   total                128
   ----------------------------------------------
   final_hex: C232AB00-9414-11EC-8000-9E6BDECED846

                   Figure 10: UUIDv1 Example Test Vector









Peabody & Davis          Expires 27 August 2022                [Page 24]

Internet-Draft               new-uuid-format               February 2022


   -----------------------------------------------
   field                 bits    value_hex
   -----------------------------------------------
   time_high              32      0x1EC9414C
   time_mid               16      0x232A
   time_low_and_version   16      0x6B00
   clk_seq_hi_res          8      0x80
   clock_seq_low           8      0x00
   node                   48      0x9E6BDECED846
   -----------------------------------------------
   total                 128
   -----------------------------------------------
   final_hex: 1EC9414C-232A-6B00-8000-9E6BDECED846

                   Figure 11: UUIDv6 Example Test Vector

B.2.  Example of a UUIDv7 Value

   This example UUIDv7 test vector utilizes a well-known 32-bit unix
   epoch with additional millisecond precision to fill the first 48 bits

   rand_a and rand_b are filled with random data.

   The timestamp is Tuesday, February 22, 2022 2:22:22.00 PM GMT-05:00
   represented as 0x17F21CFD130 or 1645539742000

   -------------------------------
   field      bits    value
   -------------------------------
   unix_ts_ms   48    0x017F21CFD130
   rand_a       16    0xF8B8
   var_ver       8    0xE7
   rand_b       56    0xD6A139DC9535C5
   -------------------------------
   total        128
   -------------------------------
   final: 017F21CF-D130-F8B8-E7D6-A139DC9535C5

                   Figure 12: UUIDv7 Example Test Vector

B.3.  Example of a UUIDv8 Value

   This example UUIDv8 test vector utilizes a well-known 64-bit unix
   epoch with nanosecond precision to fill the first 64 bits through
   ver_var.

   The final 56 bits are filled with random data.




Peabody & Davis          Expires 27 August 2022                [Page 25]

Internet-Draft               new-uuid-format               February 2022


   Timestamp is Tuesday, February 22, 2022 2:22:22.000000 PM GMT-05:00
   represented as 0x16D6320C3D4DCC00 or 1645557742000000000

   It should be noted that this example is just to illustrate one
   scenario for UUIDv8.  Test vectors will likely be implementation
   specific and vary greatly from this simple example.

   -------------------------------
   field      bits    value
   -------------------------------
   custom_a     64    0x16D6320C3D4DCC00
   var_ver       8    0xE8
   custom_b     56    0x3C2D06302FC417
   -------------------------------
   total        128
   -------------------------------
   final: 16D6320C-3D4D-CC00-E83C-2D06302FC417

                   Figure 13: UUIDv8 Example Test Vector

Authors' Addresses

   Brad G. Peabody
   Email: brad@peabody.io


   Kyzer R. Davis
   Email: kydavis@cisco.com























Peabody & Davis          Expires 27 August 2022                [Page 26]
