



dispatch                                                    BGP. Peabody
Internet-Draft                                                          
Updates: 4122 (if approved)                                     K. Davis
Intended status: Standards Track                        13 February 2022
Expires: 17 August 2022


                            New UUID Formats
               draft-peabody-dispatch-new-uuid-format-02

Abstract

   This document presents new UUID formats which address the concerns of
   time-ordered sequencing, reduction of complexity by separating
   minimum requirements from implementation suggestions, a more compact
   text format, support for variable lengths, and general suitability
   for use as a database key.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 17 August 2022.

Copyright Notice

   Copyright (c) 2022 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Revised BSD License text as
   described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Revised BSD License.



Peabody & Davis          Expires 17 August 2022                 [Page 1]

Internet-Draft               new-uuid-format               February 2022


Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   2
   2.  Background  . . . . . . . . . . . . . . . . . . . . . . . . .   3
   3.  Summary of Changes  . . . . . . . . . . . . . . . . . . . . .   5
     3.1.  changelog . . . . . . . . . . . . . . . . . . . . . . . .   5
   4.  UUID Version 6  . . . . . . . . . . . . . . . . . . . . . . .   6
     4.1.  Format  . . . . . . . . . . . . . . . . . . . . . . . . .   6
     4.2.  Creating a UUIDv6 Value . . . . . . . . . . . . . . . . .   7
   5.  UUID Version 7  . . . . . . . . . . . . . . . . . . . . . . .   8
     5.1.  Format  . . . . . . . . . . . . . . . . . . . . . . . . .   8
     5.2.  Creating a UUIDv7 Value . . . . . . . . . . . . . . . . .   9
     5.3.  Example of a UUIDv7 Value . . . . . . . . . . . . . . . .   9
   6.  UUID Version 8  . . . . . . . . . . . . . . . . . . . . . . .   9
     6.1.  Format  . . . . . . . . . . . . . . . . . . . . . . . . .   9
     6.2.  Creating a UUIDv8 Value . . . . . . . . . . . . . . . . .  10
   7.  UUID Concerns . . . . . . . . . . . . . . . . . . . . . . . .  10
     7.1.  Implementation Tradeoffs  . . . . . . . . . . . . . . . .  10
     7.2.  Storing UUIDs, Opacity  . . . . . . . . . . . . . . . . .  10
     7.3.  Combined Variant and Version Fields . . . . . . . . . . .  11
     7.4.  Length (Variable, 128-bit Default)  . . . . . . . . . . .  11
     7.5.  Text Format . . . . . . . . . . . . . . . . . . . . . . .  12
     7.6.  Sorting . . . . . . . . . . . . . . . . . . . . . . . . .  12
     7.7.  Timestamp Granularity . . . . . . . . . . . . . . . . . .  13
     7.8.  Monotonicity and Counters . . . . . . . . . . . . . . . .  13
     7.9.  Global and Local Uniqueness . . . . . . . . . . . . . . .  14
     7.10. Collision Resistance  . . . . . . . . . . . . . . . . . .  14
     7.11. Unguessability  . . . . . . . . . . . . . . . . . . . . .  15
     7.12. Shared Knowledge  . . . . . . . . . . . . . . . . . . . .  15
     7.13. Documentation . . . . . . . . . . . . . . . . . . . . . .  16
   8.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  16
   9.  Security Considerations . . . . . . . . . . . . . . . . . . .  16
   10. Acknowledgements  . . . . . . . . . . . . . . . . . . . . . .  17
   11. Normative References  . . . . . . . . . . . . . . . . . . . .  17
   12. Informative References  . . . . . . . . . . . . . . . . . . .  17
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  18

1.  Introduction

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [RFC2119].









Peabody & Davis          Expires 17 August 2022                 [Page 2]

Internet-Draft               new-uuid-format               February 2022


2.  Background

   A lot of things have changed in the time since UUIDs were originally
   created.  Modern applications have a need to create and utilize UUIDs
   as the primary identifier for a variety of different items in complex
   computational systems, including but not limited to database primary
   keys, file names, machine or system names, identifiers for
   transactions or other objects or processes.

   A specific use case for UUIDs which has gained popularity is as
   database primary keys.  The motivation for this stems primarily from
   the fact that applications are increasingly distributed in nature.
   Simplistic "auto increment" schemes with integers in sequence do not
   work well in a distributed system since the effort required to
   synchronize such numbers across a network can easily become a burden.
   The fact that UUIDs can be used to create unique and reasonably short
   values in distributed systems without requiring synchronization makes
   them a good candidate for use as a database key in such environments.

   Previous UUID versions 1 through 5 suffer from at least the following
   shortcomings:

   1.  Non-time-ordered UUID versions such as UUIDv4 have poor database
       index locality.  Meaning new values created in succession are not
       close to each other in the index and thus require inserts to be
       performed at random locations.  The negative performance effects
       of which on common structures used for this (B-tree and its
       variants) can be dramatic.

   2.  Introspection/parsing is required to order by time sequence (as
       opposed to being able to peform a simple byte-by-byte comparision

   3.  UUIDv1 utilizes a non-standard timestamp epoch derived from the
       Gregorian Calendar.  More specifically, the Coordinated Universal
       Time (UTC) as a count of 100-nanosecond intervals since
       00:00:00.00, 15 October 1582.

   4.  Privacy and network security issues arise from using a MAC
       address in the node field of Version 1 UUIDs.  Exposed MAC
       addresses can be used as an attack surface to locate machines and
       reveal various other information about such machines (minimally
       manufacturer, potentially other details).

   5.  Many implementation details are specified in [RFC4122] but some
       of the decisions made involve tradeoffs that are neither possible
       to specify for all applications nor necessary to produce
       interoperable implementations.




Peabody & Davis          Expires 17 August 2022                 [Page 3]

Internet-Draft               new-uuid-format               February 2022


   6.  The previous specification also does not distinguish between the
       requirements for generation of a UUID versus an application which
       simply stores one, which are different.

   7.  The only specified text format is unnecessarily verbose at 225%
       the length of the raw bytes.

   8.  A fixed length restricts the options of implementations to choose
       between having shorter (and e.g. values easier for humans to read
       and use) and less unique values, or having longer yet more unique
       values.

   Due to the shortcomings of UUIDv1 and UUIDv4, many widely distributed
   database applications and large application vendors have sought to
   solve the problem of creating a better time-based, sortable unique
   identifier for use as a database key.  This has lead to numerous
   implementations over the past 10+ years solving the same problem in
   slightly different ways.

   While preparing this specification the following 16 different
   implementations were analyzed for trends in total ID length, bit
   Layout, lexical formatting/encoding, timestamp type, timestamp
   format, timestamp accuracy, node format/components, collision
   handling and multi-timestamp tick generation sequencing.

   1.   [ULID] by A.  Feerasta
   2.   [LexicalUUID] by Twitter
   3.   [Snowflake] by Twitter
   4.   [Flake] by Boundary
   5.   [ShardingID] by Instagram
   6.   [KSUID] by Segment
   7.   [Elasticflake] by P.  Pearcy
   8.   [FlakeID] by T.  Pawlak
   9.   [Sonyflake] by Sony
   10.  [orderedUuid] by IT.  Cabrera
   11.  [COMBGUID] by R.  Tallent
   12.  [SID] by A.  Chilton
   13.  [pushID] by Google
   14.  [XID] by O.  Poitrey
   15.  [ObjectID] by MongoDB
   16.  [CUID] by E.  Elliott

   An inspection of these implementations and the issues described above
   has led to this document which attempts to adapt UUIDs to address
   these issues.






Peabody & Davis          Expires 17 August 2022                 [Page 4]

Internet-Draft               new-uuid-format               February 2022


   Note that there are similarities between [ULID] and UUID version 7 as
   described in this document.  In any case, the point here is to
   formalize new UUID formats in a way that is backward compatible with
   UUID and takes into account all of the concerns mentioned herein.

3.  Summary of Changes

   The following UUIDs are hereby introduced:

   1.  UUID version 6: A re-ordering of UUID version 1 so it is sortable
       as an opaque sequence of bytes.  Easy to implement given an
       existing UUIDv1 implementation.
   2.  UUID version 7: A new format which is simpler, time-ordered and
       specified in a way that separates UUID generation requirements
       from generation recommendations from storage requirements.
   3.  UUID version 8: A free-form UUID format which has no explicit
       requirements except maintaining backward compatibility.

3.1.  changelog

   RFC EDITOR PLEASE DELETE THIS SECTION.

   draft-03

      - UUIDv7 changed to simplify timestsamp mechanism to just
      millisecond unix timestamp
      - Reworked to make it more concise

   draft-02

      - Added Changelog
      - Fixed misc. grammatical errors
      - Fixed section numbering issue
      - Fixed some UUIDvX reference issues
      - Changed all instances of "motonic" to "monotonic"
      - Changed all instances of "#-bit" to "# bit"
      - Changed "proceeding" veriage to "after" in section 7
      - Added details on how to pad 32 bit unix timestamp to 36 bits in
      UUIDv7
      - Added details on how to truncate 64 bit unix timestamp to 36
      bits in UUIDv7
      - Added forward reference and bullet to UUIDv8 if truncating 64
      bit Unix Epoch is not an option.
      - Fixed bad reference to non-existent "time_or_node" in section
      4.5.4

   draft-01




Peabody & Davis          Expires 17 August 2022                 [Page 5]

Internet-Draft               new-uuid-format               February 2022


      - Complete rewrite of entire document.
      - The format, flow and verbiage used in the specification has been
      reworked to mirror the original RFC 4122 and current IETF
      standards.
      - Removed the topics of UUID length modification, alternate UUID
      text formats, and alternate UUID encoding techniques.
      - Research into 16 different historical and current
      implementations of time-based universal identifiers was completed
      at the end of 2020 in attempt to identify trends which have
      directly influenced design decisions in this draft document
      (https://github.com/uuid6/uuid6-ietf-draft/tree/master/research)
      - Prototype implementation have been completed for UUIDv6, UUIDv7,
      and UUIDv8 in various languages by many GitHub community members.
      (https://github.com/uuid6/prototypes)

4.  UUID Version 6

4.1.  Format

   UUID version 6 aims to be the easiest new version to implement by
   using the same information from a UUID version 1 and changing the
   order of the timestamp value.

   Instead of splitting the timestamp into the low, mid and high
   sections from UUIDv1, UUIDv6 changes this sequence so the timestamp
   is stored from most to least significant.  I.e.  Given a 60-bit
   timestamp value as specified for UUIDv1 in [RFC4122], Section 4.1.4,
   for UUIDv6, the first 48 most significant bits are stored first,
   followed by the 4-bit version (same position), followed by the
   remaining 12 bits.

   The format for the 16-byte, 128 bit UUIDv6 is shown in Figure 1

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                            time_top                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |            time_top           |  ver  |     time_bottom       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                   Figure 1: UUIDv6 Field and Bit Layout





Peabody & Davis          Expires 17 August 2022                 [Page 6]

Internet-Draft               new-uuid-format               February 2022


   time_top:
      The most significant 48 bits of the 60-bit timestamp.  Occupies
      bits 0 through 47 (octets 0-5).

   ver:
      The version value, set to 6 (0110b).  Occupies bits 48 through 51
      (top 4 bits of octet 6).

   time_bottom:
      The remaining 12 bits of the 60-bit timestamp.  Occupies bits 52
      through 63 (bottom 4 bits of octet 6 and octets 7-8)

   remaining bytes:
      The rest of the bytes remain unchanged from UUIDv1, although see
      next for more explanation.

   In the specification for UUIDv1, the clock sequence [RFC4122],
   Section 4.1.5 and node value [RFC4122], Section 4.1.6 have specific
   behaviors prescribed for them.  For UUIDv6, such requirements are
   relaxed.  Implementations may choose to continue to using the
   previous behavior, or refer to the sections on (TODO, links)
   Monotonicity and Collision Resistance and implement appropriate
   behavior described therein.

4.2.  Creating a UUIDv6 Value

   Here is a function in C which converts from a UUID version 1 to
   version 6:























Peabody & Davis          Expires 17 August 2022                 [Page 7]

Internet-Draft               new-uuid-format               February 2022


   #include <stdio.h>
   #include <stdint.h>
   #include <inttypes.h>
   #include <arpa/inet.h>
   #include <uuid/uuid.h>

   /* Converts UUID version 1 to version 6 in place. */
   void uuidv1tov6(uuid_t u) {

     uint64_t ut;
     unsigned char *up = (unsigned char *)u;

     // load ut with the first 64 bits of the UUID
     ut = ((uint64_t)ntohl(*((uint32_t*)up))) << 32;
     ut |= ((uint64_t)ntohl(*((uint32_t*)&up[4])));

     // dance the bit-shift...
     ut =
       ((ut >> 32) & 0x0FFF) | // 12 least significant bits
       (0x6000) | // version number
       ((ut >> 28) & 0x0000000FFFFF0000) | // next 20 bits
       ((ut << 20) & 0x000FFFF000000000) | // next 16 bits
       (ut << 52); // 12 most significant bits

     // store back in UUID
     *((uint32_t*)up) = htonl((uint32_t)(ut >> 32));
     *((uint32_t*)&up[4]) = htonl((uint32_t)(ut));

   }

                       Figure 2: UUIDv6 Function in C

5.  UUID Version 7

5.1.  Format

   UUID version 7 is a time-ordered value intended to be simpler and
   more flexible than version 6.

   The length of a UUIDv7 value is variable with a default of 128 bits.
   See (Length section below, TODO: link)










Peabody & Davis          Expires 17 August 2022                 [Page 8]

Internet-Draft               new-uuid-format               February 2022


    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           unix_ts_ms                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          unix_ts_ms           |             rand              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    var_ver    |             rand...                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                   Figure 3: UUIDv7 Field and Bit Layout

   unix_ts_ms:
      48-bit big-endian unsigned number of milliseconds since midnight 1
      January 1970 UTC.  Follows the same rules as a UNIX timestamp,
      i.e. does not include leap seconds.

   var_ver:
      The 8-bit combined variant and version field with the value 0xE7.
      (TODO: link to explanation below)

   rand:
      Psuedo-random data to provide uniquness (TODO: link to rand source
      explanation below) (TODO: link to counter section below)

5.2.  Creating a UUIDv7 Value

   TODO: some C code here showing how to generate, including option for
   counter

5.3.  Example of a UUIDv7 Value

   TODO: show one or more UUIDv7 values with the field/value breakdown

6.  UUID Version 8

6.1.  Format

   UUID version 8 provides a backward compatible UUID format which
   otherwise has no restrictions on format.

   The length of a UUIDv8 value is variable with a default of 128 bits.
   See (Variable Length section below)






Peabody & Davis          Expires 17 August 2022                 [Page 9]

Internet-Draft               new-uuid-format               February 2022


    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                            custom                             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                            custom                             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    var_ver    |            custom...                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                   Figure 4: UUIDv8 Field and Bit Layout

   custom:
      Custom sections can be filled as the implementation sees fit.  A
      typical implementation would fill

   var_ver:
      The 8-bit combined variant and version field with the value 0xE8.
      (TODO: link to explanation below)

6.2.  Creating a UUIDv8 Value

   TODO: some psuedocode here showing how to generate

7.  UUID Concerns

7.1.  Implementation Tradeoffs

   The minimum requirements for generating UUIDs are described above for
   each version.  Storing UUIDs requires only that the exact value is
   recorded.  Everything else is an implementation detail and up to you
   to decide what is appropriate for your implementation.  Various
   relevant factors are covered below to help guide which tradeoffs are
   better for different UUID implementations.

7.2.  Storing UUIDs, Opacity

   UUIDs SHOULD be treated as opaque values unless there is a good
   reason to do otherwise (i.e. implementations SHOULD NOT examine the
   bits in a UUID to whatever extent is possible.)









Peabody & Davis          Expires 17 August 2022                [Page 10]

Internet-Draft               new-uuid-format               February 2022


   As such, any storage mechanism capable of storing a series of bytes
   (minimum 9, maximum 64) is a valid storage mechanism for UUIDs.  If
   an implementation chooses to only support 128-bit UUIDs, then
   anything that can store 16 bytes is valid.  Implementations which
   store UUIDs are not required or advised to have an understanding of
   their contents.

   A UUID with all zero bytes is never valid (per this doc and the
   allowed values per [RFC4122]).  Implementations which much check if a
   UUID is present and/or valid can usually be simplified to verifying
   if a UUID is zero.  The intention is simplify implementations and
   make them more robust by removing unnecessary complexity.

   For applications which go against this advice and must inspect UUIDs,
   extracting the version number can be done by examining the variant
   field at bits 64 and 65 for the values 1 and 0 respectively, and then
   extract the version from bits 48 through 51.  UUID versions 7 and 8
   can be identified by checking octet 9 for the values 0xE7 or 0xE8
   repspectively.  The version number can then be used to inspect the
   remainder of the UUID according to the specification for that
   version.

   If you want to embed custom stuff in a UUID, you do so at your own
   risk; UUIDv8 is best suited for this

   UUIDs can be stored in binary form or as text, as appropriate for
   individual systems.  Storing as binary requires less space and may
   result in faster data access.  Storing as text requires more space
   but may require less translation if the resulting text form is to be
   used after retrieval and thus maybe simpler to implement.

7.3.  Combined Variant and Version Fields

   For UUID versions 7 and 8, the version and variant fields from
   [RFC4122] have been combined into the ver_var field described herein.
   Since the bits of the variant remain in the same place as described
   in [RFC4122] but utilized the previously reserved value 111b, this
   allows us to simply define octect 9 as ver_var, and the values 0xE7
   and 0xE8 indicate UUID versions 7 and 8 respectively.

7.4.  Length (Variable, 128-bit Default)

   Default is still 128-bits, 16 bytes.  Implementations SHOULD default
   to this.







Peabody & Davis          Expires 17 August 2022                [Page 11]

Internet-Draft               new-uuid-format               February 2022


   Implementations MAY choose to allow generation UUIDs of anywhere from
   9 to 64 bytes.  (decide if we want to elaborate on the various
   possible motivations for this here, e.g. shorter for better human
   use, longer for lower collision probability)

   Implementations that store UUIDs of variable length SHOULD support
   any length from 9 to 64 bytes (decide if this is the right range -
   less than 9 bytes and we lose the variant/version, and 64 is
   arbitrary but we should have some upper limit in case it has an
   impact on physical storage requirements)

   Variable length is optional and implementations MAY opt-out and only
   support 128-bits.

   Recommendation is for implementations to start defining UUID as an
   array of bytes (length + pointer or whatever language mechanism)
   instead of a fixed set of 16 bytes.

   I think we need a table in here that gives bit/byte lengths and
   collision probability.  So someone can look down the numbers and pick
   the one that is right for their app.

7.5.  Text Format

   Existing hex format is still valid.  Shorter or longer values just
   omit or add hex characters (give some examples at different lengths)

   Crockford base32 is allowed also (briefly summarize reasons -
   shorter, more compact if UUIDs are stored as text, crockford
   version's benefits vs).

   Parsers can use the presence of '-' to determine if it's hex or
   crockford base32 format.

   Compatible parsers MUST support crockford base32 with or without
   padding, and allow a checksum part (verifyin the checksum is
   optional)

   Base32 text encoder SHOULD output crockford base32 values without
   padding or checksum by default.  The padding or checksum features MAY
   be used if warranted for a specific application.

7.6.  Sorting

   Implementations that require sorting (e.g. database indexes) SHOULD
   sort as opaque raw bytes (UUIDv6 and 7 are designed for this),
   without examining the contents at all.




Peabody & Davis          Expires 17 August 2022                [Page 12]

Internet-Draft               new-uuid-format               February 2022


   Implementations MAY implement more complex sorting rules for UUID
   versions < 6 (or strictly speaking they MAY do this for any version,
   but shouldn't need to).

   One of the big benefits of time ordering is "index locality" - new
   values are near each other in the index and can much more easily be
   clustered together for better performance.  Real-world differences vs
   random data can be quite large.

7.7.  Timestamp Granularity

   Implementations SHOULD use the current timestamp to provide values
   that are time-ordered and continually increasing.

   It's okay to "fuzz" timestamp values here for various reasons
   (security, clock inaccuracy, etc.), there is no absolute guarantee
   about how close the clock value needs to be to actual time - that's
   implementation-specific.

   Give some examples

7.8.  Monotonicity and Counters

   (the old clock seq, can be optionally implemented, doesn't help that
   muc in distributed environment)

   This is really just for v7:

   defined simply as "each value returned is greater than the last"

   Implementations SHOULD return monotonic values where it is feasible.
   E.g. in a single library, effort should be made to return successive
   values that count up.

   You can do this with an emedded sequence counter, by waiting for the
   next clock tick, or by checking that in case of next value has same
   timestamp see that the random bytes part is greater than prior value
   and generate new random bytes and check again.  Describe trade offs
   of these approaches, but it's implemenatation-specific - no
   mandedated sequence counter.

   Provide a clear suggestion of a recommended way (e.g. something as
   simple as: "if next UUID is >= last, generate again until timestamp
   or random bytes provide a value that is higher" - maybe consider a
   max limit for cases where the system clock rolls back).

   The monotonicity properties of an particular UUID generator SHOULD
   stated in it's documentation.



Peabody & Davis          Expires 17 August 2022                [Page 13]

Internet-Draft               new-uuid-format               February 2022


7.9.  Global and Local Uniqueness

   Global uniquess is impossible to guarantee without shared knowledge.
   I.e. two systems cannot come up with two numbers completely
   independently without some possibility of collission UNLESS they
   agree on some mechanism to ensure uniqueness ahead of time (e.g. your
   numbers always end with ... and mine always end with... or whatever)

   RFC4122 tried to use MAC address as shared knowledge - it sort of
   worked but had problems (security issues with exposing MAC addresses,
   guarantee of actual global uniqueness is questionable)

   mention that "shared knowledge" is intentionally not required for
   implementation and this is part of the design, but...

   So instead just decide if you need 100% guarantee of uniqueness.  If
   so, implement shared knowledge approach (see section below)

   If not, reduce probability of uniqueness to acceptable level for your
   application.

   It is okay if implementations only provide "local" uniqueness, e.g.
   unique within one database instance or cluster of machines - as long
   as the implementation A) states that and B) the value can be
   reasonably expected to remain only in that system.  I.e. don't use
   this unique-within-this-database UUID across databases and the docs
   need to state this.

   Implementations which do not know the uniqueness requirements of the
   final application and cannot implement shared knowledge should just
   be made as unique as possible and state that.

7.10.  Collision Resistance

   In the absence of shared knowledge, collisions cannot be fully
   prevented, only the probability reduced.

   Give the math and some examples.

   Variable length allows you to further reduce collision probably
   beyond 128-bits if needed.  If we give the math, then people can make
   their own decisions based on their app.

   v7 is time ordered for better index locality/database performance, v8
   has lower collision resistance, pick your poison.






Peabody & Davis          Expires 17 August 2022                [Page 14]

Internet-Draft               new-uuid-format               February 2022


7.11.  Unguessability

   Some applications acquire security benefits from generating values
   that cannot be predicted (this is related to collision resistance,
   but not the same thing).

   Using a cryptographically secure pseudo-random number generator
   (CSPRNG) provides values that are both difficult to predict
   ("unguessable") and have a low likelyhood of collision ("unique").
   And so this is the recommended approach.

   Length is a factor too (TODO: link to wherever we list out
   probabilities)

7.12.  Shared Knowledge

   Means a pre-arranged agreement about how different systems or pieces
   of code will each produce different values.

   Examples: A section of the "random" part gets devoted to: database
   node number, MAC or IP address, manually entered ID, etc.  Or it
   could be something like the UUID generator in a database
   implementation simply checks to ensure the UUID is not in use before
   generating.  Regardless, the concept is that an implementation MAY
   just make up a rule that ensures uniqueness, at the cost of some
   guessability.

   Using a shared knowledge pattern with the same length of UUID
   increases guessability (the more bits that fit a known value or
   pattern, the easier a value is to guess).

   Shared knowledge solutions are okay and MAY be done as long as this
   is stated in the UUID implementation docs.

   Talk a bit about the cost of collision, e.g.
   https://github.com/uuid6/uuid6-ietf-draft/
   issues/36#issuecomment-903295070














Peabody & Davis          Expires 17 August 2022                [Page 15]

Internet-Draft               new-uuid-format               February 2022


   Mention that the reason this spec does not endorse any specific
   global registry is because if something goes wrong with it (like the
   fact that MAC addresses used to be more or less unique but with cloud
   computing and software network interfaces being commonplace that
   assumption changed) - in this case random data results in lower
   collision probability.  So basically we're saying: Global registries,
   aside from being inconvenient, can still have problems and thus the
   collision probability jumps way up above the random data approach -
   so let's not even bother.  If an application wants a "perfect,
   guaranteed unique" solution, it provide it within it's own
   application via shared knowledge.

7.13.  Documentation

   We say in various places that certain things should be stated in the
   implementation docs.  So we should probably have a list here... If
   you make a UUID implementation, provide a clear statement in the
   documentation about each of these points:

   1.  Timestamp granularity (v7 only)
   2.  Monotoncity (v7 only do the values always count up)
   3.  Uniqueness scope (are these values supposed to be globally unique
       or unique with a specific context, if so which context)
   4.  Shared knowledge system (if any)
   5.  Collision resistance math (use the table in this spec if it
       helps)
   6.  Unguessability (how strong is the random number generator for how
       many bits)

8.  IANA Considerations

   This document has no IANA actions.

9.  Security Considerations

   MAC addresses pose inherent security risks and MUST not be used for
   node generation.  As such they have been strictly forbidden from
   time-based UUIDs within this specification.  Instead pseudo-random
   bits SHOULD selected from a source with sufficient entropy to ensure
   guaranteed uniqueness among UUID generation.

   Timestamps embedded in the UUID do pose a very small attack surface.
   The timestamp in conjunction with the clock sequence does signal the
   order of creation for a given UUID and it's corresponding data but
   does not define anything about the data itself or the application as
   a whole.  If UUIDs are required for use with any security operation
   within an application context in any shape or form then [RFC4122]
   UUIDv4 SHOULD be utilized.



Peabody & Davis          Expires 17 August 2022                [Page 16]

Internet-Draft               new-uuid-format               February 2022


10.  Acknowledgements

   The authors gratefully acknowledge the contributions of Ben Campbell,
   Ben Ramsey, Fabio Lima, Gonzalo Salgueiro, Martin Thomson, Murray S.
   Kucherawy, Rick van Rein, Rob Wilton, Sean Leonard, Theodore Y.
   Ts'o.  As well as all of those in and outside the IETF community to
   who contributed to the discussions which resulted in this document.

11.  Normative References

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/info/rfc2119>.

   [RFC4122]  Leach, P., Mealling, M., and R. Salz, "A Universally
              Unique IDentifier (UUID) URN Namespace", RFC 4122,
              DOI 10.17487/RFC4122, July 2005,
              <https://www.rfc-editor.org/info/rfc4122>.

12.  Informative References

   [LexicalUUID]
              Twitter, "A Scala client for Cassandra", commit f6da4e0,
              November 2012,
              <https://github.com/twitter-archive/cassie>.

   [Snowflake]
              Twitter, "Snowflake is a network service for generating
              unique ID numbers at high scale with some simple
              guarantees.", Commit b3f6a3c, May 2014,
              <https://github.com/twitter-
              archive/snowflake/releases/tag/snowflake-2010>.

   [Flake]    Boundary, "Flake: A decentralized, k-ordered id generation
              service in Erlang", Commit 15c933a, February 2017,
              <https://github.com/boundary/flake>.

   [ShardingID]
              Instagram Engineering, "Sharding & IDs at Instagram",
              December 2012, <https://instagram-engineering.com/
              sharding-ids-at-instagram-1cf5a71e5a5c>.

   [KSUID]    Segment, "K-Sortable Globally Unique IDs", Commit bf376a7,
              July 2020, <https://github.com/segmentio/ksuid>.






Peabody & Davis          Expires 17 August 2022                [Page 17]

Internet-Draft               new-uuid-format               February 2022


   [Elasticflake]
              Pearcy, P., "Sequential UUID / Flake ID generator pulled
              out of elasticsearch common", Commit dd71c21, January
              2015, <https://github.com/ppearcy/elasticflake>.

   [FlakeID]  Pawlak, T., "Flake ID Generator", Commit fcd6a2f, April
              2020, <https://github.com/T-PWK/flake-idgen>.

   [Sonyflake]
              Sony, "A distributed unique ID generator inspired by
              Twitter's Snowflake", Commit 848d664, August 2020,
              <https://github.com/sony/sonyflake>.

   [orderedUuid]
              Cabrera, IT., "Laravel: The mysterious "Ordered UUID"",
              January 2020, <https://itnext.io/laravel-the-mysterious-
              ordered-uuid-29e7500b4f8>.

   [COMBGUID] Tallent, R., "Creating sequential GUIDs in C# for MSSQL or
              PostgreSql", Commit 2759820, December 2020,
              <https://github.com/richardtallent/RT.Comb>.

   [ULID]     Feerasta, A., "Universally Unique Lexicographically
              Sortable Identifier", Commit d0c7170, May 2019,
              <https://github.com/ulid/spec>.

   [SID]      Chilton, A., "sid : generate sortable identifiers",
              Commit 660e947, June 2019,
              <https://github.com/chilts/sid>.

   [pushID]   Google, "The 2^120 Ways to Ensure Unique Identifiers",
              February 2015, <https://firebase.googleblog.com/2015/02/
              the-2120-ways-to-ensure-unique_68.html>.

   [XID]      Poitrey, O., "Globally Unique ID Generator",
              Commit efa678f, October 2020, <https://github.com/rs/xid>.

   [ObjectID] MongoDB, "ObjectId - MongoDB Manual",
              <https://docs.mongodb.com/manual/reference/method/
              ObjectId/>.

   [CUID]     Elliott, E., "Collision-resistant ids optimized for
              horizontal scaling and performance.", Commit 215b27b,
              October 2020, <https://github.com/ericelliott/cuid>.

Authors' Addresses





Peabody & Davis          Expires 17 August 2022                [Page 18]

Internet-Draft               new-uuid-format               February 2022


   Brad G. Peabody

   Email: brad@peabody.io


   Kyzer R. Davis

   Email: kydavis@cisco.com











































Peabody & Davis          Expires 17 August 2022                [Page 19]
