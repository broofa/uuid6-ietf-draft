<?xml version="1.0" encoding="US-ASCII"?>
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?> <!-- used by XSLT processors -->
<!-- OPTIONS, known as processing instructions (PIs) go here. -->
<!-- For a complete list and description of PIs,
please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable PIs that most I-Ds might want to use. -->
<?rfc strict="yes" ?> <!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC): -->
<?rfc toc="yes"?> <!-- generate a ToC -->
<?rfc tocdepth="3"?> <!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references: -->
<?rfc symrefs="yes"?> <!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?> <!-- sort the reference entries alphabetically -->
<!-- control vertical white space: 
(using these PIs as follows is recommended by the RFC Editor) -->
<!-- end of popular PIs -->
<rfc version="3" category="std" updates="4122" submissionType="IETF" consensus="true" ipr="trust200902" docName="draft-peabody-dispatch-new-uuid-format-02">
	<front>
		<title abbrev="new-uuid-format">New UUID Formats</title>
		<seriesInfo name="Internet-Draft" value="draft-peabody-dispatch-new-uuid-format-02" stream="IETF"/>
		<author fullname="Brad G. Peabody" initials="BGP" surname="Peabody">
			<address>
				<email>brad@peabody.io</email>
			</address>
		</author>
		<author fullname="Kyzer R. Davis" initials="K" surname="Davis">
			<address>
				<email>kydavis@cisco.com</email>
			</address>
		</author>
		<date year="2022" />
		<area>ART</area>
		<workgroup>dispatch</workgroup>
		<keyword>uuid</keyword>
		<abstract>
			<t>
				This document presents new time-based Universally Unique Identifier (UUID) formats which are suited for use as a database key.
			</t>
			<t>
				A common case for modern applications is to create a unique identifier for use as a primary key in a database table.
				This identifier usually implements an embedded timestamp that is sortable using the monotonic creation time in the most significant bits. 
				In addition the identifier is highly collision resistant, difficult to guess, and provides minimal security attack surfaces.
				None of the existing UUID versions, including UUIDv1, fulfill each of these requirements in the most efficient possible way.
				This document is a proposal to update <xref target="RFC4122"/> with three new UUID versions that address these concerns, each with different trade-offs.
			</t>
		</abstract>
	</front>
	<middle>
		<section anchor="Background" title="Introduction">

			<t>
				Many things have changed in the time since UUIDs were originally created.
				Modern applications have a need to create and utilize UUIDs as the primary
				identifier for a variety of different items in complex computational systems,
				including but not limited to database primary keys, file names, machine
				or system names, identifiers for transactions or other objects or processes.
			</t>

			<t>
				A specific use case for UUIDs which has gained popularity is as database primary keys.
				The motivation for this stems primarily from the fact that applications
				are increasingly distributed in nature. Simplistic "auto increment" schemes
				with integers in sequence do not work well in a distributed system since the effort required to
				synchronize such numbers across a network can easily become a burden.  
				The fact that UUIDs can be used to create unique and reasonably short values in 
				distributed systems without requiring synchronization makes them a good candidate 
				for use as a database key in such environments.
			</t>

			<t>
				UUID versions 1 through 5 lack certain desirable characteristics in some circumstances:
			</t>
			<ol>
				<li><t>Non-time-ordered UUID versions such as UUIDv4 have poor database index locality.
					Meaning new values created in succession are not close to each other in the index and thus require 
					inserts to be performed at random locations. The negative performance effects of which on 
					common structures used for this (B-tree and its variants) can be dramatic.
				</t></li>	
				<li><t>
					Introspection/parsing is required to order by time sequence (as opposed to being able to perform a simple byte-by-byte comparison.
				</t></li>
				<li><t>
					The 100-nanosecond, Gregorian epoch used in UUIDv1 timestamps is uncommon and difficult to represent accurately using a standard number format such as <xref target="IEEE754"/>.
				</t></li>
				<li><t>
					Privacy and network security issues arise from using a MAC address in the node field of Version 1 UUIDs.
					Exposed MAC addresses can be used as an attack surface to locate machines and reveal various other
					information about such machines (minimally manufacturer, potentially other details). Additionally, with the advent of virtual machines and containers, MAC address uniqueness is no longer guaranteed.
				</t></li>
				<li><t>
					Many implementation details are specified in <xref target="RFC4122"/> but some of the decisions made involve trade offs that are neither possible to specify for all applications nor necessary to produce interoperable implementations.
				</t></li>
				<li><t>
					The previous specification also does not distinguish between the requirements for generation of a UUID versus an application which simply stores one, which are different.
				</t></li>
				<li><t>
					The hex-octet-and-hyphen string notation results in strings is not particularly compact.
				</t></li>
				<li><t>
					A fixed length restricts the options of implementations to choose between having shorter (and e.g. values easier for humans to read and use) and less unique values, or having longer yet more unique values.
				</t></li>
			</ol>

			<t>
				Due to the aforementioned issue, many widely distributed database applications 
				and large application vendors have sought to solve the problem of creating a better 
				time-based, sortable unique identifier for use as a database key. This has lead to numerous implementations 
				over the past 10+ years solving the same problem in slightly different ways.
			</t>
			<t>
				While preparing this specification the following 16 different implementations were analyzed for trends in total ID length, bit Layout, lexical formatting/encoding, timestamp type, timestamp format, timestamp accuracy, node format/components, collision handling and multi-timestamp tick generation sequencing.
			</t>
			<ol spacing="compact">
				<li><t><xref target="ULID"/> by A. Feerasta</t></li>	
				<li><t><xref target="LexicalUUID"/> by Twitter</t></li>	
				<li><t><xref target="Snowflake"/> by Twitter</t></li>	
				<li><t><xref target="Flake"/> by Boundary</t></li>	
				<li><t><xref target="ShardingID"/> by Instagram</t></li>	
				<li><t><xref target="KSUID"/> by Segment</t></li>	
				<li><t><xref target="Elasticflake"/> by P. Pearcy</t></li>	
				<li><t><xref target="FlakeID"/> by T. Pawlak</t></li>	
				<li><t><xref target="Sonyflake"/> by Sony</t></li>	
				<li><t><xref target="orderedUuid"/> by IT. Cabrera</t></li>	
				<li><t><xref target="COMBGUID"/> by R. Tallent</t></li>	
				<li><t><xref target="SID"/> by A. Chilton</t></li>	
				<li><t><xref target="pushID"/> by Google</t></li>	
				<li><t><xref target="XID"/> by O. Poitrey</t></li>	
				<li><t><xref target="ObjectID"/> by MongoDB</t></li>	
				<li><t><xref target="CUID"/> by E. Elliott</t></li>	
			</ol>

			<t>
				An inspection of these implementations and the issues described above has led to this document which attempts to adapt UUIDs to address these issues.
			</t>

		</section>
		<section title="Terminology">
			<section anchor="requirements_language" title="Requirements Language">
				<t>
					The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they appear in all capitals, as shown here.
				</t>
			</section>
			<section anchor="acronyms" title="Abbreviations">
				<t>The following abbreviations are used in this document: </t>
				<dl newline="false" spacing="normal" indent="14" pn="section-2.2-2">
					<dt>UUID</dt><dd>Universally Unique Identifier <xref target="RFC4122"/></dd>
					<dt>CSPRNG</dt><dd>Cryptographically Secure Pseudo-Random Number Generator</dd>
					<dt>MAC</dt><dd>Media Access Control</dd>
					<dt>MSB</dt><dd>Most Significant Bit</dd>
				</dl>
			</section>
		</section>
		<section anchor="Changes" title="Summary of Changes">
			<t>
				The following UUIDs are hereby introduced:
			</t>

			<ol spacing="compact">
				<li><t>UUID version 6: A re-ordering of UUID version 1 so it is sortable as an opaque sequence of bytes.  Easy to implement given an existing UUIDv1 implementation. See <xref target="uuidv6"/></t></li>
				<li><t>UUID version 7: An entirely new time-based UUID bit layout sourced from the widely implemented and well known Unix Epoch timestamp source. See <xref target="uuidv7"/></t></li>
				<li><t>UUID version 8: A free-form time-based UUID format which has no explicit requirements except maintaining backward compatibility. See <xref target="uuidv8"/></t></li>
			</ol>

			<section anchor="changelog" title="changelog">
				<t>RFC EDITOR PLEASE DELETE THIS SECTION.</t>
				<t>draft-03</t>
				<ul spacing="compact" empty="true">
					<li><t>- Reworked the draft body to make the content more concise</t></li>
					<li><t>- UUIDv6 section reworked to just the reorder of the timestamp</t></li>
					<li><t>- UUIDv7 changed to simplify timestamp mechanism to just millisecond unix timestamp</t></li>
					<li><t>- UUIDv8 relaxed to be custom in all elements except version and variant</t></li>
					<li><t>- Changed UUIDv7 and UUIDv8 to use Variant 111.</t></li>
					<li><t>- Added C code samples for UUIDv6 and UUIDv7 in Appendix.</t></li>
					<li><t>- Added test vectors for UUIDv6 and UUIDv7 in Appendix.</t></li>
					<li><t>- Version and Variant section combined into Variant and Version Fields section.</t></li>
					<li><t>- Changed from pseudo-random number generators to cryptographically secure pseudo-random number generator (CSPRNG).</t></li>
					<li><t>- Split Encoding and Storage section into more sections: Text Format and Storing UUIDs, Opacity</t></li>
					<li><t>- Reworked Global Uniqueness under new section Global and Local Uniqueness</t></li>
					<li><t>- Distributed UUID Generation section replaced with Shared Knowledge section</t></li>
					<li><t>- Combined redundant topics from all UUIDs into sections such as Sorting, Monotonicity and Counters, Collision Resistance, and Unguessability</t></li>
					<li><t>- Node verbiage only used in UUIDv6 and v7 and v8 reference random instead</t></li>
					<li><t>- Clock sequence verbiage changed simply to counter in any section other than UUIDv6</t></li>
					<li><t>- Added Abbreviations section</t></li>
				</ul>
				<t>draft-02</t>
				<ul spacing="compact" empty="true">
					<li><t>- Added Changelog</t></li>
					<li><t>- Fixed misc. grammatical errors</t></li>
					<li><t>- Fixed section numbering issue</t></li>
					<li><t>- Fixed some UUIDvX reference issues</t></li>
					<li><t>- Changed all instances of "motonic" to "monotonic"</t></li>
					<li><t>- Changed all instances of "#-bit" to "# bit"</t></li>
					<li><t>- Changed "proceeding" verbiage to "after" in section 7</t></li>
					<li><t>- Added details on how to pad 32 bit unix timestamp to 36 bits in UUIDv7</t></li>
					<li><t>- Added details on how to truncate 64 bit unix timestamp to 36 bits in UUIDv7</t></li>
					<li><t>- Added forward reference and bullet to UUIDv8 if truncating 64 bit Unix Epoch is not an option.</t></li>
					<li><t>- Fixed bad reference to non-existent "time_or_node" in section 4.5.4</t></li>
				</ul>
				<t>draft-01</t>
				<ul spacing="compact" empty="true">
					<li><t>- Complete rewrite of entire document.</t></li>
					<li><t>- The format, flow and verbiage used in the specification has been reworked to mirror the original RFC 4122 and current IETF standards.</t></li>
					<li><t>- Removed the topics of UUID length modification, alternate UUID text formats, and alternate UUID encoding techniques.</t></li>
					<li><t>- Research into 16 different historical and current implementations of time-based universal identifiers was completed at the end of 2020 in attempt to identify trends which have directly influenced design decisions in this draft document (https://github.com/uuid6/uuid6-ietf-draft/tree/master/research)</t></li>
					<li><t>- Prototype implementation have been completed for UUIDv6, UUIDv7, and UUIDv8 in various languages by many GitHub community members. (https://github.com/uuid6/prototypes)</t></li>
				</ul>
			</section>
		</section>
		<section anchor="format" title="Format">
			<t>The UUID format is 16 octets; some bits of the eight octet variant field specified below determine finer structure.</t>
			<section anchor="variant_and_version_fields" title="Variant and Version Fields">
				<t>
				The variant bits utilized by UUIDs in this specification 
				remain in the same octet as originally defined by <xref target="RFC4122" sectionFormat="comma" section="4.1.1"/>. 
				</t>
				<t>For UUIDv6 the version and variant field placement from <xref target="RFC4122"/> are unchanged and a new version (0110b [6]) has been added.				
				</t>
				<figure>
					<name>UUIDv6 Version and Variant Examples</name>
					<artwork><![CDATA[
00000000-0000-6000-8000-000000000000
00000000-0000-6000-9000-000000000000
00000000-0000-6000-A000-000000000000
00000000-0000-6000-B000-000000000000
xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx
					]]></artwork>
				</figure>
				<dl newline="false">
					<dt>M:</dt> <dd>Version (0110b [6])</dd>
					<dt>N:</dt> <dd>Variant (1000b [8], 1001b [9], 1010b [A] or 1011b [B]) are all valid values</dd>
				</dl>
				<t>
					For UUID versions 7 and 8, the variant field has been incremented and the version field has been moved to the same octet as the variant. Since the bits of the variant remain in the same place as described in <xref target="RFC4122"/> but utilized the previously reserved value 111, this allows a UUID to simply define octet 8 as var_ver, and the values 0xE7 and 0xE8 indicate UUID versions 7 and 8 respectively.
				</t>
				<figure>
					<name>UUIDv7 Version and Variant Examples</name>
					<artwork><![CDATA[
00000000-0000-0000-E700-000000000000
xxxxxxxx-xxxx-xxxx-NMxx-xxxxxxxxxxxx

00000000-0000-0000-E800-000000000000
xxxxxxxx-xxxx-xxxx-NMxx-xxxxxxxxxxxx
					]]></artwork>
				</figure>
				<dl newline="false">
					<dt>N:</dt> <dd>Variant (1110b [E])</dd>
					<dt>M:</dt> <dd>Version (0111b [7] or 1000 [8])</dd>
				</dl>
								
				<t>
				While this specification makes use of the unused variant bits of 111 defined in <xref target="RFC4122" sectionFormat="comma" section="4.1.1"/>; the placement of the version within the same octet as the variant leaves room for a future variant.
				</t>
				<t>
				UUID Version 7 and 8 specified by this document MUST set the first 3 bits of octet 8 to 111 and the fourth bit to 0. The 4 bit version MUST follow the variant to fill out the final bits of octet 8.
				</t>
				<t>
				Future specifications that wish to utilize variant 111 for a different version position (or any other bit layout position) MUST set the first 3 bits of octet 8 to 111 and then the fourth bit to 1.
				</t>
				<t>
				As such the tables below detail the three variants and versions described in this document where the letter "x" indicates a "don't-care" value.
				</t>
				<table>
				<name>UUID Variant defined by this specification</name>
				<thead>
					<tr><td>Msb0</td><td>Msb1</td><td>Msb2</td><td>Msb3</td><td>Description</td></tr>
				</thead>
				<tbody>
					<tr><td>1</td><td>0</td><td>x</td><td>x</td><td>The variant specified by <xref target="RFC4122"/>. Hex characters 8, 9, A, B.</td></tr>
					<tr><td>1</td><td>1</td><td>1</td><td>0</td><td>The variant specified in this document. Hex character E,</td></tr>
					<tr><td>1</td><td>1</td><td>1</td><td>1</td><td>Reserved for future definition. Hex Character F.</td></tr>
				</tbody>
				</table>

				<table>
				<name>UUID versions defined by this specification</name>
				<thead>
					<tr><td>Msb0</td><td>Msb1</td><td>Msb2</td><td>Msb3</td><td>Version</td><td>Description</td></tr>
				</thead>
				<tbody>
					<tr><td>0</td><td>1</td><td>1</td><td>0</td><td>6</td><td>Reordered Gregorian time-based UUID</td></tr>
					<tr><td>0</td><td>1</td><td>1</td><td>1</td><td>7</td><td>Unix Epoch time-based UUID</td></tr>
					<tr><td>1</td><td>0</td><td>0</td><td>0</td><td>8</td><td>Custom time-based UUID</td></tr>
				</tbody>
				</table>
				
			</section>
			<section anchor="uuidv6" title="UUID Version 6">
				<t>
					UUID version 6 is a field-compatible version of UUIDv1, reordered for improved DB locality. 
					It is expected that UUIDv6 will primarily be used in contexts where there are existing v1 UUIDs.
					Systems that do not involve legacy UUIDv1 SHOULD consider using UUIDv7 instead.
				</t>

				<t>
					Instead of splitting the timestamp into the low, mid and high sections from UUIDv1, UUIDv6 changes this sequence so timestamp bytes are stored from most to least significant.  
					That is, given a 60 bit timestamp value as specified for UUIDv1 in <xref target="RFC4122" sectionFormat="comma" section="4.1.4"/>,
					for UUIDv6, the first 48 most significant bits are stored
					first, followed by the 4 bit version (same position), followed by the remaining 12 bits of the original 60 bit timestamp.
				</t>
				<t>
					The clock sequence bits remain unchanged from their usage and position in <xref target="RFC4122" sectionFormat="comma" section="4.1.5"/>.
				</t>
				<t>
					The 48 bit node SHOULD be set to a pseudo-random value however implementations MAY choose retain the old MAC address behavior from <xref target="RFC4122" sectionFormat="comma" section="4.1.6"/> and <xref target="RFC4122" sectionFormat="comma" section="4.5"/>. For more information on MAC address usage within UUIDs see the <xref target="Security"/>
				</t>
				<t>
					The format for the 16-byte, 128 bit UUIDv6 is shown in Figure 1
				</t>
<figure>
<name>UUIDv6 Field and Bit Layout</name>
<artwork>
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                           time_high                           |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |           time_mid            |      time_low_and_version     |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |clk_seq_hi_res |  clk_seq_low  |         node (0-1)            |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                         node (2-5)                            |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</artwork>
</figure>
		<dl newline="true">
        <dt>time_high:</dt> <dd>The most significant 32 bits of the 60 bit starting timestamp.
            Occupies bits 0 through 31 (octets 0-3)</dd>
			
        <dt>time_mid:</dt> <dd>The middle 16 bits of the 60 bit starting timestamp.
            Occupies bits 32 through 47 (octets 4-5)</dd>
			
        <dt>time_low_and_version:</dt> <dd>The first four most significant bits MUST contain
            the UUIDv6 version (0110) while the remaining 12 bits will contain
            the least significant 12 bits from the 60 bit starting timestamp.
            Occupies bits 48 through 63 (octets 6-7)</dd>
			
        <dt>clk_seq_hi_res:</dt> <dd>The first two bits MUST be set to the UUID variant (10)
            The remaining 6 bits contain the high portion of the clock sequence.
            Occupies bits 64 through 71 (octet 8)</dd>
			
        <dt>clock_seq_low:</dt> <dd>The 8 bit low portion of the clock sequence.
            Occupies bits 72 through 79 (octet 9)</dd>
			
        <dt>node:</dt> <dd>48 bit spatially unique identifier
            Occupies bits 80 through 127 (octets 10-15)</dd>
		</dl>
		
						<t>
				With UUIDv6 the steps for splitting the timestamp into time_high and time_mid are optional
				since the 48 bits of time_high and time_mid will remain in the same order.
				An extra step of splitting the first 48 bits of the timestamp into the most significant 
				32 bits and least significant 16 bits proves useful when reusing an existing UUIDv1 implementation.
				In which the following logic can be applied to reshuffle the bits with minimal modifications.
				</t>
				<table>
				<name>UUIDv1 to UUIDv6 Field Mappings</name>
				<thead>
					<tr><td>UUIDv1 Field</td><td>Bits</td><td>UUIDv6 Field</td></tr>
				</thead>
				<tbody>
					<tr><td>time_low </td><td>32</td><td>time_high</td></tr>
					<tr><td>time_mid </td><td>16</td><td>time_mid</td></tr>
					<tr><td>time_high</td><td>12</td><td>time_low</td></tr>
				</tbody>
				</table>
			</section>
			<section anchor="uuidv7" title="UUID Version 7">
				<t>
					UUID version 7 features a time-ordered value field derived from the widely implemented and well known Unix Epoch timestamp source, as well as improved entropy characteristics over versions 1 or 6.
					Implementations SHOULD utilize UUID version 7 over UUID version 1 and 6 if possible. 
				</t>
				<figure>
					<name>UUIDv7 Field and Bit Layout</name>
					<artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           unix_ts_ms                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|      unix_ts_ms       |                  rand_a               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    var_ver    |            rand_b                             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                            rand_b                             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
					]]></artwork>

				</figure>

				<dl newline="true">
					<dt>unix_ts_ms:</dt> <dd>44 bit big-endian unsigned number of milliseconds since midnight 1 January 1970 UTC.  Follows the same rules as a UNIX timestamp, i.e. does not include leap seconds.</dd>
					<dt>rand_a:</dt> <dd>20 bits pseudo-random data to provide uniqueness as per <xref target="unguessability"/></dd>
					<dt>var_ver:</dt> <dd>The 8 bit combined variant and version field with the value 0xE7 as defined by <xref target="variant_and_version_fields"/>.</dd>
					<dt>rand_b:</dt> <dd>The final 56 bits of pseudo-random data to provide uniqueness as per <xref target="unguessability"/> and <xref target="monotonicity_counters"/>.</dd>
				</dl>

			</section>
			<section anchor="uuidv8" title="UUID Version 8">
				<t>
					UUID version 8 provides an RFC-compatible format for experimental or vendor-specific use cases involving time-based UUIDs.
					The only requirement is that the variant and version bits MUST be set as defined in <xref target="variant_and_version_fields"/>. 
					UUIDv8's uniqueness will be implementation-specific and should not be assumed.
				</t>
				<t>
				UUIDv8 SHOULD only be utilized if an implementation cannot utilize UUIDv1, UUIDv6, or UUIDv7.
				</t>
				<t>
				Some situations in which UUIDv8 usage could occur:
				</t>
				<ul>
					<li><t>An implementation would like to utilize a timestamp source
					  not defined by the current time-based UUIDs.</t></li>
					<li><t>An implementation would like to utilize a timestamp bit layout
					  not defined by the current time-based UUIDs.</t></li>
					<li><t>An implementation would like a specific level of precision
					  within the timestamp not offered by current time-based UUIDs.</t></li>
					<li><t>An implementation would like to embed extra information
					  within the UUID other than what is defined in this document.</t></li>
					<li><t>An implementation has other application/language restrictions which
					  inhibit the usage of one of the current time-based UUIDs.</t></li>
				</ul>
				<t>
				The only explicitly defined bits are the Version and Variant leaving 120 bits
				for implementation specific time-based UUIDs. To be clear:
				UUIDv8 is not a replacement for UUIDv4 where all 122 extra bits are
				filled with random data. UUIDv8's 128 bits (including the version and variant)
				SHOULD contain at the minimum a timestamp of some format.
				</t>
				<figure>
					<name>UUIDv8 Field and Bit Layout</name>
					<artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           custom_a                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           custom_a                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    var_ver    |           custom_b                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           custom_b                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
					]]></artwork>

				</figure>
				<dl newline="true">
					<dt>custom_a:</dt> <dd>The first 64 bits of the layout that can be filled as an implementation sees fit.</dd>
					<dt>var_ver:</dt> <dd>The 8 bit combined variant and version field with the value 0xE8 as defined by <xref target="variant_and_version_fields"/>.</dd>
					<dt>custom_b:</dt> <dd>The final 56 bits of the layout immediatly following the var_var field to be filled as an implementation sees fit.</dd>
				</dl>
			</section>			
		</section>

		<section anchor="uuid_best_practices" title="UUID Best Practices">
				<t>
					The minimum requirements for generating UUIDs are 
					described in this document for each version.  Storing UUIDs
					requires only that the exact value is recorded.
					Everything else is an implementation detail and 
					up to the implementer to decide what is appropriate for a given 
					implementation. That being said, various relevant factors are covered
					below to help guide an implementer through the different trade-offs among differing UUID implementations.
				</t>

			<section anchor="storing_uuids_opacity" title="Storing UUIDs, Opacity">
				<t>
					UUIDs SHOULD be treated as opaque values unless there is a good reason to do otherwise (i.e. implementations SHOULD NOT examine the bits in a UUID to whatever extent is possible.)
				</t>
				<t>
					As such, any storage mechanism capable of storing a series of bytes (minimum 9, maximum 64) is a valid storage mechanism for UUIDs.  If an implementation chooses to only support 128 bit UUIDs, then anything that can store 16 bytes is valid.  Implementations which store UUIDs are not required or advised to have an understanding of their contents.
				</t>
				<t>
					Where necessary, the version number may be extracted by first verifying the variant field bits 64 and 65 contain 1 and 0 respectively, and then extract the version from bits 48 through 51.
					UUID versions 7 and 8 can be identified by checking octet 8 for the values 0xE7 or 0xE8 respectively.
					The version number can then be used to inspect the remainder of the UUID according to the specification for that version.
					See <xref target="variant_and_version_fields"/> for more information on determining a UUID version based on the inspected variant bits.
				</t>

				<t>
					In the event that custom elements are required an implementer SHOULD utilize UUIDv8. <xref target="uuidv8"/>
				</t>
				<t>
					UUIDs can be stored in binary form or as text, as appropriate for individual systems. Storing as binary requires less space and may result in faster data access. Storing as text requires more space but may require less translation if the resulting text form is to be used after retrieval and thus maybe simpler to implement.
				</t>
			</section>

			<section anchor="text_format" title="Text Format">
				<t>
				The UUID length of 16 octets (128 bits) remains unchanged. The textual representation of a UUID consisting of 36
				hexadecimal and dash characters in the format 8-4-4-4-12 remains unchanged for human readability.
				</t>
			</section>

			<section anchor="sorting" title="Sorting">
				<t>
					UUIDv6 and UUIDv7 are designed so that implementations that require sorting (e.g. database indexes) SHOULD sort as opaque raw bytes, without examining the contents at all.
				</t>
				<t>
					Implementations MAY implement more complex sorting rules for UUID versions 1 through 5 (or strictly speaking they MAY do this for any version, but shouldn't need to).
				</t>
				<t>
					One of the big benefits of time ordering is "index locality" - new values are near each other in the index and can much more easily be clustered together for better performance.  Real-world differences vs random data can be quite large.
				</t>
			</section>

			<section anchor="timestamp_granularity" title="Timestamp Granularity">
				<t>
					Implementations SHOULD use the current timestamp to provide values that are time-ordered and continually increasing.
				</t>
				<t>
					It's okay to "fuzz" timestamp values here for various reasons (security, clock inaccuracy, etc.), there is no absolute guarantee about how close the clock value needs to be to actual time - that's implementation-specific.
				</t>
				<!--
					TODO: Give some examples
				-->
			</section>

			<section anchor="monotonicity_counters" title="Monotonicity and Counters">
				<t>
					(the old clock seq, can be optionally implemented, doesn't help that much in distributed environment)
				</t>

				<t>
					Within UUIDv7 it can be said that "each value returned is greater than the last" due to the embedded counter.
				</t>
				<t>
					Implementations SHOULD return monotonic values where it is feasible. E.g. in a single library, effort should be made to return successive values that count up.
				</t>
				<t>
					Implementations can achieve monotonic sequencing with an embedded sequence counter:
				</t>
				<ul spacing="compact"><!-- TODO: Describe trade offs of these approaches, but it's implementation-specific - no mandated sequence counter. -->
					<li><t>By waiting for the next clock tick</t></li>
					<li><t>By comparing the current timestamp against the previously stored timestamp. If the current timestamp is greater than the previous timestamp; generate new random bytes.</t></li>
				</ul>
				
				
				<t>
					Provide a clear suggestion of a recommended way (e.g. something as simple as: "if next UUID is &gt;= last, generate again until timestamp or random bytes provide a value that is higher" - maybe consider a max limit for cases where the system clock rolls back).
				</t>
				<t>
					The monotonicity properties of an particular UUID generator SHOULD stated in it's documentation.
				</t>
			</section>

			<section anchor="global_local_uniqueness" title="Global and Local Uniqueness">
				<t>
					Global uniqueness is impossible to guarantee without shared knowledge.  I.e. two systems cannot come up with two numbers completely independently without some possibility of collision UNLESS they agree on some mechanism to ensure uniqueness ahead of time (e.g. your numbers always end with ... and mine always end with... or whatever)
				</t>
				<t>
					RFC4122 tried to use MAC address as shared knowledge - it sort of worked but had problems (security issues with exposing MAC addresses defined in <xref target="Security"/>, guarantee of actual global uniqueness is questionable)
				</t>
				<t>
					A shared knowledge scheme is not required by the UUID to provide uniqueness guarantees. 
					Implementations MAY implement a shared knowledge scheme as they see fit to extend the uniqueness guaranteed by this UUIDs in this specification and <xref target="RFC4122"/>.
				</t>
				<t>
					So instead just decide if you need 100% guarantee of uniqueness.  If so, implement shared knowledge approach (see section below)
				</t>
				<t>
					If not, reduce probability of uniqueness to acceptable level for your application.
				</t>
				<t>
					It is okay if implementations only provide "local" uniqueness, e.g. unique within one database instance or cluster of machines - as long as the implementation A) states that and B) the value can be reasonably expected to remain only in that system.  I.e. don't use this unique-within-this-database UUID across databases and the docs need to state this.
				</t>
				<t>
					Implementations which do not know the uniqueness requirements of the final application and cannot implement shared knowledge should just be made as unique as possible and state that.
				</t>
			</section>

			<section anchor="collision_resistance" title="Collision Resistance">
				<t>
					In the absence of shared knowledge, collisions cannot be fully prevented, only the probability reduced.
				</t>
				<t>
					v7 is time ordered for better index locality/database performance, v8 has lower collision resistance, pick your poison.
				</t>
			</section>

			<section anchor="unguessability" title="Unguessability">

				<t>
					Some applications acquire security benefits from generating values that cannot be predicted (this is related to collision resistance, but not the same thing).
				</t>
				<t>
					Implementations SHOULD utilize a cryptographically secure pseudo-random number generator (CSPRNG) provides values that are both difficult to predict ("unguessable") and have a low likelihood of collision ("unique"). 
				</t>

			</section>

			<section anchor="shared_knowledge" title="Shared Knowledge">
				<t>
					Means a prearranged agreement about how different systems or pieces of code will each produce different values.
				</t>
				<t>
					Examples: A section of the "random" part gets devoted to: database node number, MAC or IP address, manually entered ID, etc.  Or it could be something like the UUID generator in a database implementation simply checks to ensure the UUID is not in use before generating.  Regardless, the concept is that an implementation MAY just make up a rule that ensures uniqueness, at the cost of some guessability.
				</t>
				<t>
					Using a shared knowledge pattern with the same length of UUID increases guessability (the more bits that fit a known value or pattern, the easier a value is to guess).
				</t>
				<t>
					Shared knowledge solutions are okay and MAY be done as long as this is stated in the UUID implementation docs.
				</t>
				<!--
					TODO: Talk a bit about the cost of collision, e.g. https://github.com/uuid6/uuid6-ietf-draft/issues/36#issuecomment-903295070
				-->
				<t>
					Mention that the reason this spec does not endorse any specific global registry is because if something goes wrong with it (like the fact that MAC addresses used to be more or less unique but with cloud computing and software network interfaces being commonplace that assumption changed) - in this case random data results in lower collision probability.  So basically we're saying: Global registries, aside from being inconvenient, can still have problems and thus the collision probability jumps way up above the random data approach - so let's not even bother.  If an application wants a "perfect, guaranteed unique" solution, it provide it within it's own application via shared knowledge.
				</t>
			</section>

			<section anchor="documentation" title="Documentation">
				<t>
					We say in various places that certain things should be stated in the implementation docs.  So we should probably have a list here... If you make a UUID implementation, provide a clear statement in the documentation about each of these points:
				</t>
				<ol spacing="compact">
					<li><t>Timestamp granularity (v7 only)</t></li>
					<li><t>Monotoncity (v7 only do the values always count up)</t></li>
					<li><t>Uniqueness scope (are these values supposed to be globally unique or unique with a specific context, if so which context)</t></li>
					<li><t>Shared knowledge system (if any)</t></li>
					<li><t>Collision resistance math (use the table in this spec if it helps)</t></li>
					<li><t>Unguessability (how strong is the random number generator for how many bits)</t></li>
				</ol>
			</section>

		</section>


		<section anchor="IANA" title="IANA Considerations">
			<t>This document has no IANA actions.</t>
		</section>

		<section anchor="Security" title="Security Considerations">
			<t> 
				MAC addresses pose inherent security risks and MUST not be used within a UUID. 
				As such they have been strictly forbidden from time-based UUIDs within this specification.
				Instead pseudo-random data SHOULD selected from a source with sufficient entropy to ensure guaranteed
				uniqueness among UUID generation. See <xref target="unguessability"/> for more information. 
			</t>
			<t>
				Timestamps embedded in the UUID do pose a very small attack surface. The timestamp in conjunction with 
				an embedded counter does signal the order of creation for a given UUID and it's corresponding data but 
				does not define anything about the data itself or the application as a whole. If UUIDs are required for
				use with any security operation within an application context in any shape or form then <xref target="RFC4122"/> UUIDv4 
				SHOULD be utilized.
			</t>
		</section>

		<section anchor="Acknowledgements" title="Acknowledgements">
			<t>The authors gratefully acknowledge the contributions of 
				Ben Campbell,
				Ben Ramsey,
				Fabio Lima,
				Gonzalo Salgueiro, 
				Martin Thomson,
				Murray S. Kucherawy,
				Rick van Rein,
				Rob Wilton,
				Sean Leonard,
				Theodore Y. Ts'o.,
				Robert Kieffer,
				sergeyprokhorenko
				As well as all of those in the IETF community and on GitHub to who contributed to the discussions which resulted in this document.
			</t>
		</section>

	</middle>

	<back>
		<references title="Normative References">
			<reference anchor="RFC2119" target="https://www.rfc-editor.org/info/rfc2119" quoteTitle="true" derivedAnchor="RFC2119">
				<front>
					<title>Key words for use in RFCs to Indicate Requirement Levels</title>
					<author initials="S." surname="Bradner" fullname="S. Bradner">
						<organization showOnFrontPage="true"/>
					</author>
					<date year="1997" month="March"/>
					<abstract>
						<t indent="0">In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
					</abstract>
				</front>
				<seriesInfo name="BCP" value="14"/>
				<seriesInfo name="RFC" value="2119"/>
				<seriesInfo name="DOI" value="10.17487/RFC2119"/>
			</reference>
			<reference anchor="RFC8174" target="https://www.rfc-editor.org/info/rfc8174" quoteTitle="true" derivedAnchor="RFC8174">
			  <front>
				<title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
				<author initials="B." surname="Leiba" fullname="B. Leiba">
				  <organization showOnFrontPage="true"/>
				</author>
				<date year="2017" month="May"/>
				<abstract>
				  <t indent="0">RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t>
				</abstract>
			  </front>
			  <seriesInfo name="BCP" value="14"/>
			  <seriesInfo name="RFC" value="8174"/>
			  <seriesInfo name="DOI" value="10.17487/RFC8174"/>
			</reference>
			<reference anchor="RFC4122" target="https://www.rfc-editor.org/info/rfc4122">
				<front>
					<title>A Universally Unique IDentifier (UUID) URN Namespace</title>
					<author initials="P." surname="Leach" fullname="P. Leach">
						<organization/>
					</author>
					<author initials="M." surname="Mealling" fullname="M. Mealling">
						<organization/>
					</author>
					<author initials="R." surname="Salz" fullname="R. Salz">
						<organization/>
					</author>
					<date year="2005" month="July"/>
					<abstract>
						<t>This specification defines a Uniform Resource Name namespace for UUIDs (Universally Unique IDentifier), also known as GUIDs (Globally Unique IDentifier). A UUID is 128 bits long, and can guarantee uniqueness across space and time. UUIDs were originally used in the Apollo Network Computing System and later in the Open Software Foundation\'s (OSF) Distributed Computing Environment (DCE), and then in Microsoft Windows platforms.</t>
						<t>This specification is derived from the DCE specification with the kind permission of the OSF (now known as The Open Group). Information from earlier versions of the DCE specification have been incorporated into this document. [STANDARDS-TRACK]</t>
					</abstract>
				</front>
				<seriesInfo name="RFC" value="4122"/>
				<seriesInfo name="DOI" value="10.17487/RFC4122"/>
			</reference>
		</references>
		<references title="Informative References">
			<reference anchor="LexicalUUID" target="https://github.com/twitter-archive/cassie">
				<front>
					<title>A Scala client for Cassandra</title>
					<author>
						<organization showOnFrontPage="true">Twitter</organization>
					</author>
					<date month="November" year="2012" />
				</front>
				<seriesInfo name="commit" value="f6da4e0" />
			</reference>
			<reference anchor="Snowflake" target="https://github.com/twitter-archive/snowflake/releases/tag/snowflake-2010">
				<front>
					<title>Snowflake is a network service for generating unique ID numbers at high scale with some simple guarantees.</title>
					<author>
						<organization showOnFrontPage="true">Twitter</organization>
					</author>
					<date month="May" year="2014" />
				</front>
				<seriesInfo name="Commit" value="b3f6a3c" />
			</reference>
			<reference anchor="Flake" target="https://github.com/boundary/flake">
				<front>
					<title>Flake: A decentralized, k-ordered id generation service in Erlang</title>
					<author>
						<organization showOnFrontPage="true">Boundary</organization>
					</author>
					<date month="February" year="2017" />
				</front>
				<seriesInfo name="Commit" value="15c933a" />
			</reference>
			<reference anchor="ShardingID" target="https://instagram-engineering.com/sharding-ids-at-instagram-1cf5a71e5a5c">
				<front>
					<title>Sharding &#038; IDs at Instagram</title>
					<author>
						<organization showOnFrontPage="true">Instagram Engineering</organization>
					</author>
					<date month="December" year="2012" />
				</front>
			</reference>
			<reference anchor="KSUID" target="https://github.com/segmentio/ksuid">
				<front>
					<title>K-Sortable Globally Unique IDs</title>
					<author>
						<organization showOnFrontPage="true">Segment</organization>
					</author>
					<date month="July" year="2020" />
				</front>
				<seriesInfo name="Commit" value="bf376a7" />
			</reference>
			<reference anchor="Elasticflake" target="https://github.com/ppearcy/elasticflake">
				<front>
					<title>Sequential UUID / Flake ID generator pulled out of elasticsearch common</title>
					<author initials="P" surname="Pearcy" fullname="Paul Pearcy">
						<organization />
					</author>
					<date month="January" year="2015" />
				</front>
				<seriesInfo name="Commit" value="dd71c21" />
			</reference>
			<reference anchor="FlakeID" target="https://github.com/T-PWK/flake-idgen">
				<front>
					<title>Flake ID Generator</title>
					<author initials="T" surname="Pawlak" fullname="Tom Pawlak">
						<organization />
					</author>
					<date month="April" year="2020" />
				</front>
				<seriesInfo name="Commit" value="fcd6a2f" />
			</reference>
			<reference anchor="Sonyflake" target="https://github.com/sony/sonyflake">
				<front>
					<title>A distributed unique ID generator inspired by Twitter's Snowflake</title>
					<author>
						<organization showOnFrontPage="true">Sony</organization>
					</author>
					<date month="August" year="2020" />
				</front>
				<seriesInfo name="Commit" value="848d664" />
			</reference>
			<reference anchor="orderedUuid" target="https://itnext.io/laravel-the-mysterious-ordered-uuid-29e7500b4f8">
				<front>
					<title>Laravel: The mysterious "Ordered UUID"</title>
					<author initials="IT" surname="Cabrera" fullname="Italo Baeza Cabrera">
						<organization />
					</author>
					<date month="January" year="2020" />
				</front>
			</reference>
			<reference anchor="COMBGUID" target="https://github.com/richardtallent/RT.Comb">
				<front>
					<title>Creating sequential GUIDs in C# for MSSQL or PostgreSql</title>
					<author initials="R" surname="Tallent" fullname="Richard Tallent">
						<organization />
					</author>
					<date month="December" year="2020" />
				</front>
				<seriesInfo name="Commit" value="2759820" />
			</reference>
			<reference anchor="ULID" target="https://github.com/ulid/spec">
				<front>
					<title>Universally Unique Lexicographically Sortable Identifier</title>
					<author initials="A" surname="Feerasta" fullname="Alizain Feerasta">
						<organization />
					</author>
					<date month="May" year="2019" />
				</front>
				<seriesInfo name="Commit" value="d0c7170" />
			</reference>
			<reference anchor="SID" target="https://github.com/chilts/sid">
				<front>
					<title>sid : generate sortable identifiers</title>
					<author initials="A" surname="Chilton" fullname="Andrew Chilton">
						<organization />
					</author>
					<date month="June" year="2019" />
				</front>
				<seriesInfo name="Commit" value="660e947" />
			</reference>
			<reference anchor="pushID" target="https://firebase.googleblog.com/2015/02/the-2120-ways-to-ensure-unique_68.html">
				<front>
					<title>The 2^120 Ways to Ensure Unique Identifiers</title>
					<author>
						<organization showOnFrontPage="true">Google</organization>
					</author>
					<date month="February" year="2015" />
				</front>
			</reference>
			<reference anchor="XID" target="https://github.com/rs/xid">
				<front>
					<title>Globally Unique ID Generator</title>
					<author initials="O" surname="Poitrey" fullname="Olivier Poitrey">
						<organization />
					</author>
					<date month="October" year="2020" />
				</front>
				<seriesInfo name="Commit" value="efa678f" />
			</reference>
			<reference anchor="ObjectID" target="https://docs.mongodb.com/manual/reference/method/ObjectId/">
				<front>
					<title>ObjectId - MongoDB Manual</title>
					<author>
						<organization showOnFrontPage="true">MongoDB</organization>
					</author>
				</front>
			</reference>
			<reference anchor="CUID" target="https://github.com/ericelliott/cuid">
				<front>
					<title>Collision-resistant ids optimized for horizontal scaling and performance.</title>
					<author initials="E" surname="Elliott" fullname="Eric Elliott">
						<organization />
					</author>
					<date month="October" year="2020" />
				</front>
				<seriesInfo name="Commit" value="215b27b" />
			</reference>
			<reference anchor="IEEE754" target="https://standards.ieee.org/ieee/754/6210/">
				<front>
					<title>Collision-resistant ids optimized for horizontal scaling and performance.</title>
					<author>
						<organization showOnFrontPage="true">IEEE</organization>
					</author>
					<date month="July" year="2019" />
				</front>
				<seriesInfo name="Series" value="754-2019" />
			</reference>
		</references>
		<section anchor="example_code" title="Example Code">
			<section anchor="creating_a_uuidv6_value" title="Creating a UUIDv6 Value">
				<t>This section details a function in C which converts from a UUID version 1 to version 6:
				</t>
				<figure>
					<name>UUIDv6 Function in C</name>
					<artwork><![CDATA[
#include <stdio.h>
#include <stdint.h>
#include <inttypes.h>
#include <arpa/inet.h>
#include <uuid/uuid.h>

/* Converts UUID version 1 to version 6 in place. */
void uuidv1tov6(uuid_t u) {

  uint64_t ut;
  unsigned char *up = (unsigned char *)u;

  // load ut with the first 64 bits of the UUID
  ut = ((uint64_t)ntohl(*((uint32_t*)up))) << 32;
  ut |= ((uint64_t)ntohl(*((uint32_t*)&up[4])));

  // dance the bit-shift...
  ut = 
    ((ut >> 32) & 0x0FFF) | // 12 least significant bits
    (0x6000) | // version number
    ((ut >> 28) & 0x0000000FFFFF0000) | // next 20 bits
    ((ut << 20) & 0x000FFFF000000000) | // next 16 bits
    (ut << 52); // 12 most significant bits

  // store back in UUID
  *((uint32_t*)up) = htonl((uint32_t)(ut >> 32));
  *((uint32_t*)&up[4]) = htonl((uint32_t)(ut));

}
					]]></artwork>
				</figure>
			</section>
			<section anchor="creating_a_uuidv7_value" title="Creating a UUIDv7 Value">
				<figure>
					<name>UUIDv7 Function in C</name>
					<artwork><![CDATA[
TODO: some C code here showing how to generate, including option for counter
					]]></artwork>
				</figure>
			</section>
		</section>
		<section anchor="test_vectors" title="Test Vectors">
			<t>Both UUIDv1 and UUIDv6 test vectors utilize the same 60-bit timestamp: 0x1EC9414C232AB00 (138648505420000000) Tuesday, February 22, 2022 2:22:22.000000 PM GMT-05:00</t>
				<figure>
					<name>Test Vector Timestamp Pseudo-code</name>
					<artwork><![CDATA[
# Unix Nanosecond precision to Gregorian 100-nanosecond intervals
gregorian_100_ns = (unix_64_bit_nanoseconds / 100) + gregorian_unix_offset

# Gregorian to Unix Offset:
# The number of 100-ns intervals between the
# UUID epoch 1582-10-15 00:00:00 and the Unix epoch 1970-01-01 00:00:00.
# gregorian_unix_offset = 0x01b21dd213814000 or 122192928000000000

# Unix 64 bit Nanosecond Timestamp:
# Unix NS: Tuesday, February 22, 2022 2:22:22 PM GMT-05:00
# unix_64_bit_nanoseconds = 0x16D6320C3D4DCC00 or 1645557742000000000

# Work:
# gregorian_100_ns = (1645557742000000000 / 100) + 122192928000000000
# (138648505420000000 - 122192928000000000) * 100 = unix_64_bit_nanoseconds

# Final:
# gregorian_100_ns = 0x1EC9414C232AB00 or 138648505420000000

# Original: 000111101100100101000001010011000010001100101010101100000000
# UUIDv1:   11000010001100101010101100000000|1001010000010100|0001|000111101100
# UUIDv6:   00011110110010010100000101001100|0010001100101010|0110|101100000000
					]]></artwork>
				</figure>			
			<section anchor="uuidv6_example" title="Example of a UUIDv6 Value">
				<figure>
					<name>UUIDv1 Example Test Vector</name>
					<artwork><![CDATA[
----------------------------------------------
field                 bits    value_hex       
----------------------------------------------
time_low              32      0xC232AB00      
time_mid              16      0x9414          
time_hi_and_version   16      0x11EC          
clk_seq_hi_res         8      0x80            
clock_seq_low          8      0x00            
node                  48      0x9E6BDECED846  
----------------------------------------------
total                128
----------------------------------------------
final_hex: C232AB00-9414-11EC-8000-9E6BDECED846
					]]></artwork>
				</figure>
				<figure>
					<name>UUIDv6 Example Test Vector</name>
					<artwork><![CDATA[
-----------------------------------------------
field                 bits    value_hex        
-----------------------------------------------
time_high              32      0x1EC9414C      
time_mid               16      0x232A          
time_low_and_version   16      0x6B00          
clk_seq_hi_res          8      0x80            
clock_seq_low           8      0x00            
node                   48      0x9E6BDECED846  
-----------------------------------------------
total                 128
-----------------------------------------------
final_hex: 1EC9414C-232A-6B00-8000-9E6BDECED846
					]]></artwork>
				</figure>
			</section>
			<section anchor="uuidv7_example" title="Example of a UUIDv7 Value">
				<t>This example UUIDv7 test vector utilizes a well-known 32-bit unix epoch with additional millisecond precision to fill the first 44 bits</t>
				<t>rand_a and rand_b are filled with random data.</t>
				<t>The timestamp is Tuesday, February 22, 2022 2:22:22.00 PM GMT-05:00 represented as 0x17F21CFD130 or 1645539742000</t>
				<figure>
					<name>UUIDv7 Example Test Vector</name>
					<artwork><![CDATA[
-------------------------------
field      bits    value
-------------------------------
unix_ts_ms   44    0x17F21CFD130
rand_a       20    0x7E9D1
var_ver       8    0xE7
rand_b       56    0xD6A139DC9535C5
-------------------------------
total        128               
-------------------------------
final: 17F21CFD-1307-E9D1-E7D6-A139DC9535C5
					]]></artwork>
				</figure>
			</section>
			<section anchor="uuidv8_example" title="Example of a UUIDv8 Value">
				<t>This example UUIDv8 test vector utilizes a well-known 64-bit unix epoch with nanosecond precision to fill the first 64 bits through ver_var.</t>
				<t>The final 56 bits are filled with random data.</t>
				<t>Timestamp is Tuesday, February 22, 2022 2:22:22.000000 PM GMT-05:00 represented as 0x16D6320C3D4DCC00 or 1645557742000000000</t>
				<t>It should be noted that this example is just to illustrate one scenario for UUIDv8. Test vectors will likely be implementation specific and vary greatly from this simple example.</t>
				<figure>
					<name>UUIDv8 Example Test Vector</name>
					<artwork><![CDATA[
-------------------------------
field      bits    value
-------------------------------
custom_a     64    0x16D6320C3D4DCC00
var_ver       8    0xE7
custom_b     56    0x3C2D06302FC417
-------------------------------
total        128               
-------------------------------
final: 16D6320C-3D4D-CC00-E73C-2D06302FC417
					]]></artwork>
				</figure>
			</section>
		</section>
	</back>
</rfc>